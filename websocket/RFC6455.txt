
[搜索] [ txt | html | pdf | 有勘误| 中文提供] [追踪] [ WG ] [电子邮件] [ DIFF1 ] [ DIFF2 ] [尼特]

来自：draft-ietf-hybi-thewebsocketprotocol-17          提议的标准
更新者：7936 , 8307 , 8441                                存在勘误
互联网工程任务组 (IETF) I. Fette
征求意见：6455 Google, Inc.
类别：标准跟踪 A. Melnikov
ISSN: 2070-1721 Isode Ltd.
                                                           2011 年 12 月


                         WebSocket 协议

抽象的

   WebSocket 协议支持客户端之间的双向通信
   在受控环境中将不受信任的代码运行到远程主机
   已选择接收来自该代码的通信。安全
   用于此的模型是常用的基于源的安全模型
   通过网络浏览器。该协议包括一个开放的握手
   其次是基本的消息帧，在 TCP 上分层。的目标
   这项技术是提供一种基于浏览器的机制
   需要与服务器进行双向通信的应用程序
   不依赖于打开多个 HTTP 连接（例如，使用
   XMLHttpRequest 或 <iframe> 和长轮询）。

本备忘录的状态

   这是一个 Internet 标准跟踪文档。

   本文档是 Internet Engineering Task Force 的产品
   (IETF)。它代表了 IETF 社区的共识。它有
   已接受公众审查并已获准出版
   互联网工程指导组 (IESG)。更多信息
   Internet 标准在RFC 5741 的第 2 节中提供。

   有关本文档当前状态的信息、任何勘误表、
   以及如何提供反馈，可以在
   http://www.rfc-editor.org/info/rfc6455。

版权声明

   版权所有 (c) 2011 IETF Trust 和被认定为
   文档作者。版权所有。

   本文档受BCP 78和 IETF Trust 的法律约束
   与 IETF 文件相关的规定
   ( http://trustee.ietf.org/license-info ) 自生效之日起生效
   本文件的发布。请查看这些文件
   仔细，因为它们描述了您的权利和限制
   到这个文件。从本文档中提取的代码组件必须




Fette & Melnikov 标准跟踪 [第 1 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   包括在第 4.e 节中描述的简化的 BSD 许可证文本
   信托法律规定，并且不作任何保证
   在简化的 BSD 许可证中描述。

目录

   1 . 介绍 。. . . . . . . . . . . . . . . . . . . . . . . .  4
     1.1 . 背景 。. . . . . . . . . . . . . . . . . . . . . . .  4
     1.2 . 协议概述。. . . . . . . . . . . . . . . . . . .  5
     1.3 . 开场握手。. . . . . . . . . . . . . . . . . . .  6
     1.4 . 结束握手。. . . . . . . . . . . . . . . . . . .  9
     1.5 . 设计理念。. . . . . . . . . . . . . . . . . . .  9
     1.6 . 安全模型。. . . . . . . . . . . . . . . . . . . . . 10
     1.7 . 与 TCP 和 HTTP 的关系。. . . . . . . . . . . . . . 11
     1.8 . 建立连接。. . . . . . . . . . . . . . . 11
     1.9 . 使用 WebSocket 协议的子协议。. . . . . . . 12
   2 . 一致性要求。. . . . . . . . . . . . . . . . . . 12
     2.1 . 术语和其他约定。. . . . . . . . . . . 13
   3 . WebSocket URI。. . . . . . . . . . . . . . . . . . . . . . . 14
   4 . 开场握手。. . . . . . . . . . . . . . . . . . . . . 14
     4.1 . 客户要求。. . . . . . . . . . . . . . . . . . 14
     4.2 . 服务器端要求。. . . . . . . . . . . . . . . . 20
       4.2.1 . 读取客户端的开始握手。. . . . . . . 21
       4.2.2 . 发送服务器的开始握手。. . . . . . . 22
     4.3 . 为握手中使用的新标头字段收集 ABNF。. 25
     4.4 . 支持多版本的 WebSocket 协议。. . . 26
   5 . 数据框架。. . . . . . . . . . . . . . . . . . . . . . . . 27
     5.1 . 概述 。. . . . . . . . . . . . . . . . . . . . . . . . 27
     5.2 . 基本帧协议。. . . . . . . . . . . . . . . . . 28
     5.3 . 客户端到服务器屏蔽。. . . . . . . . . . . . . . . . 32
     5.4 . 碎片化。. . . . . . . . . . . . . . . . . . . . . 33
     5.5 . 控制帧。. . . . . . . . . . . . . . . . . . . . . 36
       5.5.1 . 关闭 。. . . . . . . . . . . . . . . . . . . . . . . 36
       5.5.2 . 平。. . . . . . . . . . . . . . . . . . . . . . . . 37
       5.5.3 . 乒乓。. . . . . . . . . . . . . . . . . . . . . . . . 37
     5.6 . 数据帧。. . . . . . . . . . . . . . . . . . . . . . 38
     5.7 . 例子 。. . . . . . . . . . . . . . . . . . . . . . . . 38
     5.8 . 可扩展性。. . . . . . . . . . . . . . . . . . . . . 39
   6. 发送和接收数据。. . . . . . . . . . . . . . . . . 39
     6.1 . 发送数据。. . . . . . . . . . . . . . . . . . . . . . 39
     6.2 . 接收数据。. . . . . . . . . . . . . . . . . . . . . 40
   7 . 关闭连接。. . . . . . . . . . . . . . . . . . . 41
     7.1 . 定义。. . . . . . . . . . . . . . . . . . . . . . 41
       7.1.1 . 关闭 WebSocket 连接。. . . . . . . . . . . 41
       7.1.2 . 启动 WebSocket 关闭握手。. . . . . . . 42
       7.1.3 . WebSocket 关闭握手开始。. . . . . 42
       7.1.4. WebSocket 连接已关闭。. . . . . . . . . 42
       7.1.5 . WebSocket 连接关闭代码。. . . . . . . . 42



Fette & Melnikov 标准跟踪 [第 2 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


       7.1.6 . WebSocket 连接关闭原因。. . . . . . . 43
       7.1.7 . 使 WebSocket 连接失败。. . . . . . . . . . . 43
     7.2 . 异常关闭。. . . . . . . . . . . . . . . . . . . 44
       7.2.1 . 客户端启动的关闭。. . . . . . . . . . . . . . 44
       7.2.2 . 服务器启动的关闭。. . . . . . . . . . . . . . 44
       7.2.3 . 从异常关闭中恢复。. . . . . . . . . . 44
     7.3 . 正常关闭连接。. . . . . . . . . . . . . 45
     7.4 . 状态代码。. . . . . . . . . . . . . . . . . . . . . . 45
       7.4.1. 定义的状态代码。. . . . . . . . . . . . . . . . 45
       7.4.2 . 保留状态代码范围。. . . . . . . . . . . . 47
   8 . 错误处理。. . . . . . . . . . . . . . . . . . . . . . . 48
     8.1 . 处理 UTF-8 编码数据中的错误。. . . . . . . . . 48
   9 . 扩展名。. . . . . . . . . . . . . . . . . . . . . . . . . 48
     9.1 . 协商延期。. . . . . . . . . . . . . . . . . 48
     9.2 . 已知扩展。. . . . . . . . . . . . . . . . . . . . 50
   10 . 安全注意事项。. . . . . . . . . . . . . . . . . . 50
     10.1. 非浏览器客户端。. . . . . . . . . . . . . . . . . . 50
     10.2 . 原产地注意事项。. . . . . . . . . . . . . . . . . 50
     10.3 . 对基础设施的攻击（屏蔽）。. . . . . . . . . . 51
     10.4。实施特定限制。. . . . . . . . . . . . . 52
     10.5 . WebSocket 客户端身份验证。. . . . . . . . . . . . 53
     10.6 . 连接机密性和完整性。. . . . . . . . 53
     10.7 . 处理无效数据。. . . . . . . . . . . . . . . . 53
     10.8 . WebSocket Handshake 使用 SHA-1。. . . . . . . . 54
   11. IANA 考虑事项。. . . . . . . . . . . . . . . . . . . . 54
     11.1 . 新 URI 方案的注册。. . . . . . . . . . . . 54
       11.1.1。注册“ws”计划。. . . . . . . . . . . . 54
       11.1.2 . 注册“wss”计划。. . . . . . . . . . . . 55
     11.2。注册“WebSocket”HTTP 升级关键字。. . 56
     11.3。注册新的 HTTP 标头字段。. . . . . . . . . 57
       11.3.1。Sec-WebSocket-Key 。. . . . . . . . . . . . . . . . . 57
       11.3.2。Sec-WebSocket-扩展。. . . . . . . . . . . . . . 58
       11.3.3. Sec-WebSocket-接受。. . . . . . . . . . . . . . . . 58
       11.3.4。Sec-WebSocket-协议。. . . . . . . . . . . . . . . 59
       11.3.5。Sec-WebSocket-版本。. . . . . . . . . . . . . . . 60
     11.4 . WebSocket 扩展名称注册表。. . . . . . . . . . . 61
     11.5 . WebSocket 子协议名称注册表。. . . . . . . . . . 61
     11.6 . WebSocket 版本号注册表。. . . . . . . . . . . 62
     11.7。WebSocket 关闭代码注册。. . . . . . . . . . 64
     11.8 . WebSocket 操作码注册表。. . . . . . . . . . . . . . . 65
     11.9. WebSocket 帧头位注册表。. . . . . . . . . 66
   12 . 使用来自其他规范的 WebSocket 协议。. . . 66
   13 . 致谢。. . . . . . . . . . . . . . . . . . . . . . 67
   14 . 参考 。. . . . . . . . . . . . . . . . . . . . . . . . . 68
     14.1。规范参考。. . . . . . . . . . . . . . . . . . 68
     14.2。参考资料。. . . . . . . . . . . . . . . . . 69





Fette & Melnikov 标准跟踪 [第 3 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


1 . 介绍

1.1 . 背景

   _本节不规范。_

   从历史上看，创建需要双向传输的 Web 应用程序
   客户端和服务器之间的通信（例如，即时消息
   和游戏应用程序）需要滥用 HTTP 来轮询
   服务器用于更新，同时将上游通知发送为不同的
   HTTP 调用 [ RFC6202 ]。

   这会导致各种问题：

   o 服务器被迫使用多个不同的底层 TCP
      每个客户端的连接：一个用于向客户端发送信息
      客户端，并为每条传入消息创建一个新消息。

   o 有线协议的开销很高，每个客户端到服务器
      具有 HTTP 标头的消息。

   o 客户端脚本被迫维护来自
      传出连接到传入连接以跟踪回复。

   一个更简单的解决方案是使用单个 TCP 连接
   两个方向的交通。这就是 WebSocket 协议
   提供。结合 WebSocket API [ WSAPI ]，它提供了一个
   从网页进行双向通信的 HTTP 轮询的替代方法
   到远程服务器。

   相同的技术可用于各种 Web 应用程序：
   游戏、股票行情、多用户应用程序
   编辑，用户界面实时暴露服务器端服务，
   等等。

   WebSocket 协议旨在取代现有的
   使用 HTTP 作为传输的双向通信技术
   层以从现有基础设施（代理、过滤、
   验证）。此类技术被实施为权衡
   在效率和可靠性之间，因为 HTTP 最初不是
   旨在用于双向通信（参见 [ RFC6202 ]
   进一步讨论）。WebSocket 协议试图解决
   现有双向 HTTP 技术的目标
   现有的 HTTP 基础设施；因此，它旨在工作
   通过 HTTP 端口 80 和 443 以及支持 HTTP 代理和
   中介，即使这意味着某些特定于
   当前环境。但是，该设计并没有将 WebSocket 限制为
   HTTP 和未来的实现可以使用更简单的握手



Fette & Melnikov 标准跟踪 [第 4 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   专用端口，而无需重新发明整个协议。这最后
   点很重要，因为交互的流量模式
   消息传递与标准 HTTP 流量不紧密匹配，可能会导致
   某些组件上的异常负载。

1.2 . 协议概述

   _本节不规范。_

   该协议有两部分：握手和数据传输。

   来自客户端的握手如下所示：

        获取/聊天 HTTP/1.1
        主机：server.example.com
        升级：websocket
        连接：升级
        Sec-WebSocket-Key：dGhlIHNhbXBsZSBub25jZQ==
        来源：http://example.com
        Sec-WebSocket-Protocol：聊天、超级聊天
        Sec-WebSocket-版本：13

   来自服务器的握手如下所示：

        HTTP/1.1 101 交换协议
        升级：websocket
        连接：升级
        Sec-WebSocket-接受：s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
        Sec-WebSocket-Protocol：聊天

   来自客户端的引导行遵循请求行格式。
   服务器的引导行遵循状态行格式。这
   Request-Line 和 Status-Line 产生式在 [ RFC2616 ]中定义。

   一组无序的标题字段出现在
   两种情况。这些头字段的含义在
   本文件第 4 节。额外的头域也可能是
   存在，例如 cookie [ RFC6265 ]。格式和解析
   标头如 [ RFC2616 ] 中所定义。

   一旦客户端和服务器都发送了他们的握手，如果
   握手成功，然后数据传输部分开始。
   这是一个双向通信通道，每一方都可以，
   相互独立，随意发送数据。

   成功握手后，客户端和服务器将数据传回
   在本规范中称为的概念单位中
   “消息”。在线路上，一条消息由一个或多个



Fette & Melnikov 标准跟踪 [第 5 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   帧。WebSocket 消息不一定对应于
   特定的网络层帧，因为碎片消息可能是
   由中介合并或拆分。

   一个框架有一个关联的类型。属于同一帧的每一帧
   消息包含相同类型的数据。从广义上讲，有
   文本数据的类型（被解释为 UTF-8 [ RFC3629 ]
   文本）、二进制数据（其解释由
   应用程序）和控制帧（不打算携带
   应用程序的数据，而不是协议级信令，
   例如发出连接应该关闭的信号）。这个
   协议的版本定义了六种帧类型，剩下十种
   保留以备将来使用。

1.3 . 开场握手

   _本节不规范。_

   开启握手是为了兼容基于 HTTP 的
   服务器端软件和中介，以便单个端口可以
   由与该服务器和 WebSocket 通信的 HTTP 客户端使用
   客户端与该服务器交谈。为此，WebSocket 客户端的
   握手是一个 HTTP 升级请求：

        获取/聊天 HTTP/1.1
        主机：server.example.com
        升级：websocket
        连接：升级
        Sec-WebSocket-Key：dGhlIHNhbXBsZSBub25jZQ==
        来源：http://example.com
        Sec-WebSocket-Protocol：聊天、超级聊天
        Sec-WebSocket-版本：13

   根据[ RFC2616 ]，握手中的头域可能是
   由客户端以任何顺序发送，因此不同的顺序
   接收到的头字段并不重要。

   GET 方法 [ RFC2616 ]的“Request-URI”用于标识
   WebSocket 连接的端点，两者都允许多个域
   从一个 IP 地址提供服务并允许多个 WebSocket
   由单个服务器提供服务的端点。

   客户端在 |Host| 中包含主机名。它的头域
   根据 [ RFC2616 ]握手，以便客户端和服务器
   可以验证他们同意使用哪个主机。






Fette & Melnikov 标准跟踪 [第 6 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   附加头字段用于选择 WebSocket 中的选项
   协议。此版本中可用的典型选项是
   子协议选择器（|Sec-WebSocket-Protocol|），扩展列表
   客户端支持（|Sec-WebSocket-Extensions|），|Origin| 标题
   字段等。|Sec-WebSocket-Protocol| 请求头字段可以是
   用于指示哪些子协议（应用级协议
   分层在 WebSocket 协议之上）是客户端可以接受的。
   服务器选择一种或不选择可接受的协议并回显
   握手中的那个值表明它已经选择了
   协议。

        Sec-WebSocket-Protocol：聊天

   |起源| 标头字段 [ RFC6454 ] 用于防止
   使用脚本未经授权跨源使用 WebSocket 服务器
   Web 浏览器中的 WebSocket API。服务器被告知
   生成 WebSocket 连接请求的脚本源。如果
   服务器不希望接受来自该源的连接，它可以
   选择通过发送适当的 HTTP 错误来拒绝连接
   代码。这个头域是由浏览器客户端发送的；对于非浏览器
   客户端，如果它在
   这些客户的背景。

   最后，服务器必须向客户端证明它收到了
   客户端的 WebSocket 握手，以便服务器不接受
   不是 WebSocket 连接的连接。这可以防止
   攻击者通过小心发送来欺骗 WebSocket 服务器
   使用 XMLHttpRequest [ XMLHttpRequest ] 或表单制作的数据包
   提交。

   为了证明握手已收到，服务器必须采取两个
   信息片段并将它们组合起来形成响应。首先
   一条信息来自|Sec-WebSocket-Key| 头域
   在客户端握手中：

        Sec-WebSocket-Key：dGhlIHNhbXBsZSBub25jZQ==

   对于这个头字段，服务器必须取值（如存在
   在标头字段中，例如 base64 编码的 [ RFC4648 ] 版本减去
   任何前导和尾随空格）并将其与
   全局唯一标识符（GUID，[ RFC4122 ]）“258EAFA5-E914-47DA-
   95CA-C5AB0DC85B11" 字符串形式，不太可能被使用
   不理解 WebSocket 协议的网络端点。一种
   SHA-1 哈希（160 位）[ FIPS.180-3 ]，base64 编码（参见第 4 节
   [RFC4648] )，然后在服务器的
   握手。





Fette & Melnikov 标准跟踪 [第 7 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   具体来说，如果如上例所示，|Sec-WebSocket-Key|
   标头字段的值为“dGhlIHNhbXBsZSBub25jZQ==”，服务器
   将连接字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”
   形成字符串“dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-
   C5AB0DC85B11"。然后服务器会使用它的 SHA-1 哈希值，
   给出值 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6
   0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea。这个值是
   然后 base64 编码（参见[RFC4648] 的第 4 节），给出值
   "s3pPLMBiTxaQ9kYGzzhZRbK+xOo="。然后这个值将被回显
   |Sec-WebSocket-Accept| 头字段。

   来自服务器的握手比客户端简单得多
   握手。第一行是 HTTP 状态行，状态为
   代码 101：

        HTTP/1.1 101 交换协议

   除了 101 之外的任何状态代码都表示 WebSocket 握手
   尚未完成并且 HTTP 的语义仍然适用。这
   标题遵循状态代码。

   |连接| 和 |升级| 标头字段完成 HTTP
   升级。|Sec-WebSocket-Accept| 头域表示是否
   服务器愿意接受连接。如果存在，这
   标头字段必须包含客户端发送的随机数的散列
   |Sec-WebSocket-Key| 以及预定义的 GUID。任何其他值
   不得被解释为接受连接
   服务器。

        HTTP/1.1 101 交换协议
        升级：websocket
        连接：升级
        Sec-WebSocket-接受：s3pPLMBiTxaQ9kYGzzhZRbK+xOo=

   这些字段由 WebSocket 客户端检查脚本页面。
   如果 |Sec-WebSocket-Accept| 值与预期不符
   值，如果头字段丢失，或者 HTTP 状态代码是
   不是101，连接不会建立，和WebSocket框架
   不会发送。

   还可以包括选项字段。在这个版本的协议中，
   主要选项字段是 |Sec-WebSocket-Protocol|，表示
   服务器选择的子协议。WebSocket 客户端
   验证服务器是否包含指定的值之一
   在 WebSocket 客户端的握手中。一个说多个的服务器
   子协议必须确保它根据客户端的选择选择一个
   握手并在其握手中指定它。




Fette & Melnikov 标准跟踪 [第 8 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


        Sec-WebSocket-Protocol：聊天

   服务器还可以将cookie相关的选项字段设置为_set_
   cookie，如 [ RFC6265 ] 中所述。

1.4 . 结束握手

   _本节不规范。_

   结束握手远比开始握手简单。

   任一对等方都可以发送包含指定数据的控制帧
   开始关闭握手的控制序列（详见
   第 5.5.1 节）。收到这样的帧后，其他对等方发送一个
   关闭帧作为响应，如果它还没有发送一个。之上
   接收_那个_控制帧，第一个对等体然后关闭
   连接，知道没有进一步的数据是安全的
   即将到来。

   发送指示连接的控制帧后
   关闭，对等方不再发送任何数据；在收到一个
   指示连接应该关闭的控制帧，一个对等体
   丢弃接收到的任何进一步数据。

   两个对等方同时发起此握手是安全的。

   关闭握手旨在补充 TCP 关闭
   握手（FIN/ACK），基于 TCP 关闭握手是
   并不总是可靠的端到端，尤其是在存在
   拦截代理和其他中介。

   通过发送关闭帧并等待关闭帧响应，
   避免了数据可能不必要地丢失的某些情况。为了
   例如，在某些平台上，如果套接字被数据关闭
   接收队列，发送一个 RST 数据包，这将导致 recv()
   接收 RST 的一方失败，即使有数据
   等待阅读。

1.5 . 设计理念

   _本节不规范。_

   WebSocket 协议的设计原则是：
   最小化框架（唯一存在的框架是使
   协议基于帧而不是基于流，并支持
   Unicode 文本和二进制帧之间的区别）。预计
   该元数据将由应用程序在 WebSocket 之上分层




Fette & Melnikov 标准跟踪 [第 9 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   层，就像元数据在 TCP 上分层一样
   应用层（例如，HTTP）。

   从概念上讲，WebSocket 实际上只是 TCP 之上的一层
   执行以下操作：

   o 为浏览器添加了基于 Web 源的安全模型

   o 添加了寻址和协议命名机制以支持
      一个端口上的多个服务和一个 IP 上的多个主机名
      地址

   o 在 TCP 之上分层成帧机制以返回 IP
      TCP 所建立的数据包机制，但没有长度限制

   o 包括额外的带内关闭握手
      在代理人和其他中间人在场的情况下工作

   除此之外，WebSocket 没有添加任何内容。基本上它的目的是
   鉴于以下情况，尽可能接近仅将原始 TCP 暴露给脚本
   网络的限制。它还被设计成这样
   服务器可以通过握手与 HTTP 服务器共享端口
   是有效的 HTTP 升级请求。一个人可以在概念上使用其他
   建立客户端 - 服务器消息传递的协议，但意图
   WebSockets 是提供一个比较简单的协议，可以
   与 HTTP 和部署的 HTTP 基础设施（例如代理）共存
   并且与 TCP 一样接近 TCP 可以安全地与此类一起使用
   考虑到安全性的基础设施，有针对性的添加
   简化使用并保持简单的事情简单（例如添加
   消息语义）。

   该协议旨在是可扩展的；未来的版本将
   可能会引入额外的概念，例如多路复用。

1.6 . 安全模型

   _本节不规范。_

   WebSocket 协议使用 Web 浏览器使用的原始模型来
   限制哪些网页可以联系 WebSocket 服务器
   WebSocket 协议用于网页。自然，当
   WebSocket 协议由专用客户端直接使用（即，不
   从网页通过网络浏览器），原始模型不是
   很有用，因为客户端可以提供任意源字符串。

   该协议旨在无法与
   预先存在的协议的服务器，如 SMTP [ RFC5321 ] 和 HTTP，而
   允许 HTTP 服务器选择支持此协议，如果



Fette & Melnikov 标准跟踪 [第 10 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   想要的。这是通过严格而精心的握手来实现的
   并通过限制可以插入连接的数据
   在握手完成之前（从而限制了服务器
   会受到影响）。

   同样的目的是为了在数据时建立连接失败
   来自其他协议，尤其是 HTTP，被发送到 WebSocket 服务器，
   例如，如果将 HTML“表单”提交给
   WebSocket 服务器。这主要是通过要求
   服务器证明它读取了握手，只有在
   握手包含适当的部分，只能由一个发送
   WebSocket 客户端。特别是在撰写本文时
   规范，字段以 |Sec-| 开头 不能由一个设置
   来自仅使用 HTML 和 JavaScript API 的 Web 浏览器的攻击者，例如
   作为 XMLHttpRequest [ XMLHttpRequest ]。

1.7 . 与 TCP 和 HTTP 的关系

   _本节不规范。_

   WebSocket 协议是一个独立的基于 TCP 的协议。它的
   与 HTTP 的唯一关系是它的握手被解释为
   HTTP 服务器作为升级请求。

   默认情况下，WebSocket 协议将端口 80 用于常规 WebSocket
   用于通过隧道传输的 WebSocket 连接的连接和端口 443
   传输层安全 (TLS) [ RFC2818 ]。

1.8 . 建立连接

   _本节不规范。_

   与 HTTP 共享的端口建立连接时
   服务器（这种情况很可能发生在流量到
   端口 80 和 443），连接将出现在 HTTP 服务器上
   是带有升级报价的常规 GET 请求。在比较简单的
   设置只有一个 IP 地址和一个服务器来处理所有流量
   到单个主机名，这可能为系统提供一种实用的方法
   基于要部署的WebSocket协议。在更详细的
   设置（例如，使用负载平衡器和多个服务器），一个专用的
   用于与 HTTP 服务器分开的 WebSocket 连接的主机集
   可能更容易管理。在撰写本文时
   规范，应注意端口 80 和
   443 有显着不同的成功率，连接
   端口 443 更有可能成功，尽管这可能
   随时间变化。





Fette & Melnikov 标准跟踪 [第 11 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


1.9 . 使用 WebSocket 协议的子协议

   _本节不规范。_

   客户端可以通过以下方式请求服务器使用特定的子协议
   包括 |Sec-WebSocket-Protocol| 领域在它的握手。如果它
   指定，服务器需要包含相同的字段和其中之一
   连接到的响应中选定的子协议值
   成立。

   这些子协议名称应按照第 11.5 节进行注册。到
   避免潜在的冲突，建议使用名称
   包含子协议域名的 ASCII 版本
   鼻祖。例如，如果 Example Corporation 要创建一个
   由 Web 上的许多服务器实现的聊天子协议，
   他们可以将其命名为“chat.example.com”。如果示例组织
   将他们的竞争子协议称为“chat.example.org”，然后这两个
   子协议可以由服务器同时实现，
   服务器动态选择使用哪个子协议基于
   客户端发送的值。

   子协议可以通过以下方式以向后不兼容的方式进行版本控制
   更改子协议名称，例如，从
   “bookings.example.net”到“v2.bookings.example.net”。这些
   子协议将被 WebSocket 视为完全独立的
   客户。向后兼容的版本控制可以通过
   重用相同的子协议字符串，但仔细设计
   支持这种可扩展性的实际子协议。

2 . 一致性要求

   本规范中的所有图表、示例和注释均非
   规范性，所有章节都明确标记为非规范性。
   本规范中的其他所有内容都是规范的。

   关键词“必须”、“不得”、“要求”、“应该”、“不应”、
   此处的“应该”、“不应该”、“推荐”、“可以”和“可选”
   文档将按照 [ RFC2119 ] 中的描述进行解释。

   作为算法的一部分在命令式中表述的要求（例如
   “去除任何前导空格字符”或“返回假并中止这些
   步骤”）将按照关键字的含义进行解释
   （“MUST”、“SHOULD”、“MAY”等）用于介绍算法。








Fette & Melnikov 标准跟踪 [第 12 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   表述为算法或特定步骤的一致性要求可能
   以任何方式实施，只要最终结果是
   相等的。（特别是，这里定义的算法
   规范旨在易于遵循，而不是旨在
   表现出色。）

2.1 . 术语和其他约定

   _ASCII_ 表示定义的字符编码方案
   [ ANSI.X3-4.1986 ]。

   本文档参考了 UTF-8 值并使用了 UTF-8
   STD 63 [ RFC3629 ] 中定义的符号格式。

   诸如命名算法或定义之类的关键术语表示为
   _这个_。

   标题字段或变量的名称用|this| 表示。

   变量值用 /this/ 表示。

   本文档引用了 WebSocket _Fail 的过程
   联系_。此过程在第 7.1.7 节中定义。

   _将字符串转换为 ASCII 小写_意味着替换所有
   U+0041 到 U+005A 范围内的字符（即拉丁大写字母
   A 到 LATIN CAPITAL LETTER Z) 中的相应字符
   范围 U+0061 到 U+007A（即拉丁文小写字母 A 到拉丁文小写字母 A）
   字母 Z）。

   以 _ASCII 不区分大小写的方式比较两个字符串意味着
   对它们进行精确比较，代码点对代码点，除了
   U+0041 到 U+005A 范围内的字符（即拉丁大写字母
   A 到 LATIN CAPITAL LETTER Z) 和相应的字符
   范围 U+0061 到 U+007A（即拉丁文小写字母 A 到拉丁文小写字母 A）
   字母 Z) 也被认为是匹配的。

   本文档中使用的术语“URI”在 [ RFC3986 ] 中定义。

   当一个实现需要_发送_数据作为
   WebSocket 协议，实现可能会延迟实际
   任意传输，例如缓冲数据以发送更少的IP
   数据包。

   请注意，本文档同时使用了 [ RFC5234 ] 和 [ RFC2616 ] 变体
   ABNF 在不同的部分。





Fette & Melnikov 标准跟踪 [第 13 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


3 . WebSocket URI

   本规范定义了两种 URI 方案，使用 ABNF 语法
   在RFC 5234 [ RFC5234 ] 中定义，以及术语和 ABNF 产品
   由 URI 规范RFC 3986 [ RFC3986 ] 定义。

          ws-URI = "ws:" "//" 主机 [ ":" 端口 ] 路径 [ "?" 询问 ]
          wss-URI = "wss:" "//" 主机 [ ":" 端口 ] 路径 [ "?" 询问 ]

          host = <host，定义在[RFC3986], Section 3.2.2 >
          端口 = <端口，定义于[RFC3986]，第 3.2.3 节>
          path = <path-abempty，定义在[RFC3986], Section 3.3 >
          query = <query，定义在[RFC3986], Section 3.4 >

   端口组件是可选的；“ws”的默认端口是 80，
   “wss”的默认端口是 443。

   URI 称为“安全”（据说“安全标志是
   set") 如果方案组件不区分大小写匹配“wss”。

   “资源名称”（在第 4.1 节中也称为 /resource name/ ）
   可以通过连接以下内容来构建：

   o "/" 如果路径组件为空

   o 路径组件

   “？” 如果查询组件非空

   o 查询组件

   片段标识符在 WebSocket URI 的上下文中毫无意义
   并且不得在这些 URI 上使用。与任何 URI 方案一样，
   字符“#”，当不指示片段的开始时，必须是
   转义为 %23。

4 . 开场握手

4.1 . 客户要求

   要_建立 WebSocket 连接_，客户端打开一个连接
   并发送本节中定义的握手。一个连接是
   定义为最初处于连接状态。客户需要
   提供 /host/、/port/、/resource name/ 和 /secure/ 标志，其中
   是第 3 节中讨论的 WebSocket URI 的组件，
   以及要使用的 /protocols/ 和 /extensions/ 列表。
   此外，如果客户端是 Web 浏览器，则它提供 /origin/。




Fette & Melnikov 标准跟踪 [第 14 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   在受控环境中运行的客户端，例如移动浏览器
   绑定到特定运营商的手机，可能会卸载对
   连接到网络上的另一个代理。在这种情况下，
   就本规范而言，客户被认为是
   包括手机软件和任何此类代理。

   当客户端要_建立一个 WebSocket 连接_时给定一个集合
   (/host/, /port/, /resource name/, and /secure/ flag)，以及
   要使用的 /protocols/ 和 /extensions/ 列表，以及 /origin/
   对于网络浏览器，它必须打开一个连接，发送一个打开
   握手，并读取服务器的握手响应。最正确
   应该如何打开连接的要求，应该是什么
   在开始握手时发送，以及服务器的响应应该如何
   本节解释如下。在下面的
   文本，我们将使用第 3 节中的术语，例如“/host/”和
   该部分中定义的“/secure/ flag”。

   1. 传入这个算法的WebSocket URI的组成部分
       （/host/、/port/、/resource name/ 和 /secure/ 标志）必须是
       根据指定的 WebSocket URI 规范有效
       在第 3 节。如果任何组件无效，客户端
       必须_使 WebSocket 连接失败_并中止这些步骤。

   2.如果客户端已经有到远程的WebSocket连接
       由 /host/ 和端口 /port/ 对标识的主机（IP 地址），甚至
       如果远程主机被另一个名字知道，客户端必须等待
       直到该连接已建立或为该连接
       失败了。一个连接中不得超过一个
       连接状态。如果多个连接到同一个 IP 地址
       同时尝试，客户端必须序列化它们，以便
       一次运行的连接不超过一个
       通过以下步骤。

       如果客户端无法确定远程主机的 IP 地址
       （例如，因为所有通信都是通过一个
       自己执行 DNS 查询的代理服务器），然后是客户端
       出于此步骤的目的，必须假设每个主机名
       指的是一个不同的远程主机，而不是客户端应该
       将同时挂起的连接总数限制为
       数量相当少（例如，客户端可能允许同时
       挂起到 a.example.com 和 b.example.com 的连接，但如果
       请求与单个主机的 30 个同时连接，
       这可能是不允许的）。例如，在 Web 浏览器上下文中，
       客户端需要考虑用户打开的标签数量
       在设置同时挂起数量的限制
       连接。





Fette & Melnikov 标准跟踪 [第 15 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


       注意：这使得脚本更难执行拒绝 -
       通过打开大量WebSocket进行服务攻击
       到远程主机的连接。服务器可以进一步减少
       在关闭之前暂停攻击时加载自身
       连接，因为这会降低客户端的速率
       重新连接。

       注意：建立的WebSocket数量没有限制
       客户端可以与单个远程主机建立的连接。服务器
       可以拒绝接受来自主机/IP 地址的连接
       过多的现有连接或断开资源-
       在承受高负载时占用连接。

   3. _Proxy Usage_：如果客户端配置为使用代理时
       使用 WebSocket 协议连接到主机 /host/ 和端口
       /port/，然后客户端应该连接到该代理并询问它
       打开到由 /host/ 和端口给出的主机的 TCP 连接
       由 /port/ 给出。

          示例：例如，如果客户端对所有
          流量，然后如果要尝试连接到服务器上的端口 80
          example.com，它可能会向代理发送以下几行
          服务器：

              连接 example.com:80 HTTP/1.1
              主机：example.com

          如果有密码，则连接可能如下所示：

              连接 example.com:80 HTTP/1.1
              主机：example.com
              代理授权：基本 ZWRuYW1vZGU6bm9jYXBlcyE=

       如果客户端未配置为使用代理，则直接 TCP
       连接应该被打开到 /host/ 给出的主机和
       由 /port/ 给出的端口。

       注意：不公开显式 UI 的实现
       为 WebSocket 连接选择与其他代理分开的代理
       鼓励代理使用 SOCKS5 [ RFC1928 ] 代理
       WebSocket 连接，如果可用，或失败，首选
       通过代理为 HTTPS 连接配置的代理
       配置为 HTTP 连接。

       出于代理自动配置脚本的目的，URI
       传递函数必须从 /host/、/port/、
       /resource name/ 和 /secure/ 标志使用 a 的定义第 3 节中
       给出的 WebSocket URI 。



Fette & Melnikov 标准跟踪 [第 16 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


       注意：WebSocket 协议可以在代理中识别
       方案中的自动配置脚本（“ws”表示未加密
       连接和“wss”用于加密连接）。

   4.如果无法打开连接，要么是因为直接
       连接失败或因为使用的任何代理返回错误，
       那么客户端必须_失败 WebSocket 连接_并中止
       连接尝试。

   5. 如果 /secure/ 为真，客户端必须执行 TLS 握手
       打开连接后和发送前的连接
       握手数据 [ RFC2818 ]。如果失败（例如，服务器的
       证书无法验证），那么客户端必须_Fail
       WebSocket Connection_ 并中止连接。除此以外，
       此通道上的所有进一步通信必须通过
       加密隧道 [ RFC5246 ]。

       客户端必须在 TLS 中使用服务器名称指示扩展
       握手 [ RFC6066 ]。

   一旦建立到服务器的连接（包括
   通过代理或通过 TLS 加密隧道的连接），客户端
   必须向服务器发送开始握手。握手包括
   HTTP 升级请求的列表，以及所需的和
   可选的头字段。这次握手的要求是
   如下。

   1. 握手必须是一个有效的 HTTP 请求，如指定的
        [ RFC2616 ]。

   2.请求的方法必须是GET，HTTP版本必须
        至少为 1.1。

        例如，如果 WebSocket URI 是“ws://example.com/chat”，
        发送的第一行应该是“GET /chat HTTP/1.1”。

   3.请求的“Request-URI”部分必须匹配/resource
        name/ 在第 3 节中定义（一个相对 URI）或者是一个绝对的
        http/https URI 在解析时具有 /resource name/、/host/、
        和 /port/ 匹配相应的 ws/wss URI。

   4. 请求必须包含一个 |Host| 其值的头字段
        包含 /host/ 加上可选的“：”后跟 /port/（如果不是
        使用默认端口）。

   5. 请求必须包含 |Upgrade| 其值的头字段
        必须包含“websocket”关键字。




Fette & Melnikov 标准跟踪 [第 17 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   6. 请求必须包含一个 |Connection| 其值的头字段
        必须包含“升级”令牌。

   7. 请求必须包含一个带有名字的头域
        |Sec-WebSocket-Key|。这个头域的值必须是一个
        nonce 由随机选择的 16 字节值组成，该值具有
        已被 base64 编码（参见[RFC4648] 的第 4 节）。随机数
        必须为每个连接随机选择。

        注意：例如，如果随机选择的值是
        字节序列 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09
        0x0a 0x0b 0x0c 0x0d 0x0e 0x0f 0x10，头部的值
        字段将是“AQIDBAUGBwgJCgsMDQ4PEC==”

   8. 请求必须包含一个名称为 |Origin| 的头域。
        [ RFC6454 ] 如果请求来自浏览器客户端。如果
        连接来自非浏览器客户端，请求可以
        如果该客户端的语义匹配，则包含此标头字段
        此处为浏览器客户端描述的用例。的价值
        此头字段是源的 ASCII 序列化
        建立连接的代码所在的上下文是
        跑步。有关此标头字段的详细信息，请参阅 [ RFC6454 ]
        值被构造。

        例如，如果从 www.example.com 下载的代码尝试
        建立到 ww2.example.com 的连接，值
        标头字段将是“http://www.example.com”。

   9. 请求必须包含一个带有名称的头域
        |Sec-WebSocket-版本|。这个头域的值必须是
        13.

        注意：虽然本文档的草稿版本（-09、-10、-11、
        和 -12) 已发布（它们主要由社论组成
        更改和说明，而不是对电线的更改
        协议），值 9、10、11 和 12 未用作有效值
        Sec-WebSocket-Version 的值。这些值保留在
        IANA 注册管理机构，但没有也不会使用。

   10. 请求可以包含一个带有名字的头域
        |Sec-WebSocket-协议|。如果存在，该值表示一个
        或更多以逗号分隔的子协议客户希望发言，
        按喜好排序。构成该值的元素
        必须是非空字符串，字符在 U+0021 到
        U+007E 不包括定义的分隔符
        [ RFC2616 ] 并且必须都是唯一的字符串。ABNF 为
        这个头域的值为1#token，其中的定义
        结构和规则在 [ RFC2616 ] 中给出。



Fette & Melnikov 标准跟踪 [第 18 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   11. 请求可以包含一个带有名字的头域
        |Sec-WebSocket-Extensions|。如果存在，该值表示
        客户端希望使用的协议级扩展。这
        这个头域的解释和格式在
        第 9.1 节。

   12. 请求可以包括任何其他头域，例如，
        cookie [ RFC6265 ] 和/或与身份验证相关的标头字段
        如|授权| 标头字段 [ RFC2616 ]，它们是
        根据定义它们的文档进行处理。

   一旦发送了客户端的打开握手，客户端必须
   在发送任何进一步的数据之前等待来自服务器的响应。
   客户端必须按如下方式验证服务器的响应：

   1.如果从服务器收到的状态码不是101，则
       客户端根据 HTTP [ RFC2616 ] 程序处理响应。在
       特别是，如果客户端可能会执行身份验证
       收到 401 状态码；服务器可能会重定向客户端
       使用 3xx 状态代码（但客户端不需要遵循
       它们）等。否则，请按以下步骤操作。

   2. 如果响应缺少 |Upgrade| 标题字段或 |升级|
       标头字段包含一个不是 ASCII 大小写的值 -
       值“websocket”的不敏感匹配，客户端必须
       _WebSocket 连接失败_。

   3. 如果响应缺少 |Connection| 标题字段或
       |连接| 标头字段不包含作为
       值“升级”的 ASCII 不区分大小写匹配，客户端
       必须_使 WebSocket 连接失败_。

   4. 如果响应缺少 |Sec-WebSocket-Accept| 标题字段或
       |Sec-WebSocket-Accept| 包含除
       |Sec-WebSocket- 的连接的 base64 编码 SHA-1
       钥匙| （作为字符串，而不是 base64 解码）与字符串“258EAFA5-
       E914-47DA-95CA-C5AB0DC85B11"但忽略任何前导和
       尾随空格，客户端必须 _Fail WebSocket
       联系_。

   5. 如果响应包含 |Sec-WebSocket-Extensions| 标题
       字段和此头字段指示使用扩展
       这在客户端的握手中不存在（服务器有
       表示客户端未请求的扩展），客户端
       必须_使 WebSocket 连接失败_。（这个解析
       用于确定请求哪些扩展的标头字段是
       在第 9.1 节中讨论。）




Fette & Melnikov 标准跟踪 [第 19 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   6. 如果响应包含 |Sec-WebSocket-Protocol| 头域
       并且这个头域表明使用了一个子协议
       不存在于客户端的握手中（服务器已指示
       客户端未请求的子协议），客户端必须 _Fail
       WebSocket 连接_。

   如果服务器的响应不符合要求
   本节和第 4.2.2节中定义的服务器握手，
   客户端必须_使 WebSocket 连接失败_。

   请注意，根据 [ RFC2616 ]，在
   HTTP 请求和 HTTP 响应都不区分大小写。

   如果服务器的响应按上述规定进行验证，则为
   表示 _WebSocket 连接已建立_ 并且
   WebSocket 连接处于 OPEN 状态。_使用中的扩展_
   被定义为一个（可能为空的）字符串，其值为
   等于 |Sec-WebSocket-Extensions| 的值 头域
   由服务器的握手或空值提供，如果该标头
   服务器的握手中不存在字段。_Subprotocol In
   Use_ 被定义为 |Sec-WebSocket-Protocol| 的值
   服务器握手中的标头字段或空值（如果有）
   服务器的握手中不存在标头字段。
   此外，如果服务器握手中的任何头字段表明
   应该设置 cookie（由 [ RFC6265 ]定义），这些 cookie
   被称为 _Cookies 在服务器打开期间设置
   握手_。

4.2 . 服务器端要求

   服务器可以将连接的管理卸载到其他代理
   例如，网络上的负载平衡器和反向代理。在
   在这种情况下，服务器就本规范而言
   被认为包括服务器端基础设施的所有部分
   从第一个设备终止 TCP 连接到
   处理请求和发送响应的服务器。

   示例：数据中心可能有一个响应 WebSocket 的服务器
   使用适当的握手请求然后传递连接
   到另一台服务器来实际处理数据帧。为了
   本规范的目的，“服务器”是
   两台电脑。









Fette & Melnikov 标准跟踪 [第 20 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


4.2.1 . 读取客户端的打开握手

   当客户端开始一个 WebSocket 连接时，它会发送它的一部分
   打开握手。服务器必须至少解析其中的一部分
   握手以获得生成所需的信息
   握手的服务器部分。

   客户端的开启握手由以下部分组成。如果
   服务器在读取握手时发现客户端做了
   不发送符合以下描述的握手（请注意，作为
   根据 [ RFC2616 ]，标头字段的顺序并不重要），
   包括但不限于任何违反 ABNF 语法的行为
   为握手的组件指定，服务器必须停止
   处理客户端的握手并返回一个带有
   适当的错误代码（例如 400 Bad Request）。

   1. HTTP/1.1 或更高版本的 GET 请求，包括“Request-URI”
        [ RFC2616 ] 应该被解释为 /resource name/第 3 节中
        定义的（或包含的绝对 HTTP/HTTPS URI
        /资源名称/）。

   2.一个|主持人| 包含服务器权限的头字段。

   3.一次|升级| 包含值“websocket”的标头字段，
        被视为不区分大小写的 ASCII 值。

   4. A |连接| 包含令牌“升级”的标头字段，
        被视为不区分大小写的 ASCII 值。

   5.一个|Sec-WebSocket-Key| 带有 base64 编码的标头字段（请参阅
        [RFC4648] 的第 4 节) 值，解码时为 16 个字节
        长度。

   6.一个|Sec-WebSocket-Version| header 字段，值为 13。

   7. （可选）|Origin| 头字段。这个头域被发送
        所有浏览器客户端。缺少此的连接尝试
        标头字段不应被解释为来自浏览器
        客户。

   8. 可选的，一个 |Sec-WebSocket-Protocol| 标题字段，带有列表
        指示客户端想要哪些协议的值
        说话，按喜好排序。

   9. 可选的，一个 |Sec-WebSocket-Extensions| 标头字段，带有
        指示客户端想要哪些扩展的值列表
        说话。讨论了这个头域的解释
        在第 9.1 节中。



Fette & Melnikov 标准跟踪 [第 21 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   10. 可选的，其他头字段，例如用于发送的那些
        cookie 或向服务器请求身份验证。未知标头
        字段被忽略，根据 [ RFC2616 ]。

4.2.2 . 发送服务器的开始握手

   当客户端与服务器建立 WebSocket 连接时，
   服务器必须完成以下步骤才能接受连接并
   发送服务器的开始握手。

   1. 如果连接发生在 HTTPS (HTTP-over-TLS) 端口上，
       通过连接执行 TLS 握手。如果这失败
       （例如，客户端在扩展客户端中指明了一个主机名
       你好“server_name”扩展，服务器不托管），
       然后关闭连接；否则，所有进一步的沟通
       对于连接（包括服务器的握手）必须运行
       通过加密隧道 [ RFC5246 ]。

   2.服务器可以进行额外的客户端认证，对于
       例如，通过返回带有相应的 401 状态代码
       |WWW-认证| [ RFC2616 ] 中描述的标头字段。

   3. 服务器可以使用 3xx 状态码重定向客户端
       [ RFC2616 ]。请注意，此步骤可以与之前一起发生，
       或在上述可选的身份验证步骤之后。

   4. 建立以下信息：

       /起源/
          |起源| 客户端握手中的头域表示
          建立连接的脚本的来源。这
          origin 被序列化为 ASCII 并转换为小写。这
          服务器可以使用此信息作为确定的一部分
          是否接受传入的连接。如果服务器
          不验证来源，它将接受来自
          任何地方。如果服务器不希望接受这个
          连接，它必须返回适当的 HTTP 错误代码
          （例如，403 Forbidden）并中止 WebSocket 握手
          本节中描述。有关更多详细信息，请参阅
          第 10 节。

       /钥匙/
          |Sec-WebSocket-Key| 客户端握手中的标头字段
          包括一个 base64 编码的值，如果解码，则为 16 字节
          在长度上。此（编码）值用于创建
          服务器的握手表示接受
          联系。服务器不需要base64-
          解码 |Sec-WebSocket-Key| 价值。



Fette & Melnikov 标准跟踪 [第 22 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


       /版本/
          |Sec-WebSocket-Version| 客户端的头字段
          握手包括 WebSocket 协议的版本
          客户端正在尝试通信。如果这
          版本与服务器理解的版本不匹配，
          服务器必须中止这里描述的 WebSocket 握手
          部分，而是发送适当的 HTTP 错误代码（例如
          作为 426 需要升级）和一个 |Sec-WebSocket-Version| 标题
          指示服务器能够使用的版本的字段
          理解。

       /资源名称/
          服务器提供的服务的标识符。如果
          server 提供多项服务，那么这个值应该是
          源自客户端握手中给出的资源名称
          在GET 方法的“Request-URI”[ RFC2616 ] 中。如果
          请求的服务不可用，服务器必须发送
          适当的 HTTP 错误代码（例如 404 Not Found）并中止
          WebSocket 握手。

       /子协议/
          表示服务器子协议的单个值
          准备使用或为空。选择的值必须是导出的
          从客户端的握手中，特别是通过选择其中之一
          来自 |Sec-WebSocket-Protocol| 的值 该领域的
          服务器愿意用于此连接（如果有）。如果
          客户端的握手不包含这样的头字段，或者如果
          服务器不同意客户端的任何请求
          子协议，唯一可接受的值为空。缺席的
          这样一个字段的等价于空值（意味着
          如果服务器不希望同意建议之一
          子协议，它不得发回 |Sec-WebSocket-Protocol|
          其响应中的标头字段）。空字符串不是
          与这些用途的空值相同，并且不合法
          该字段的值。此标头的值的 ABNF
          字段是（令牌），其中结构的定义和
          规则在 [ RFC2616 ] 中给出。

       /扩展/
          代表协议级别的（可能为空）列表
          服务器准备使用的扩展。如果服务器支持
          多个扩展，那么该值必须从
          客户的握手，特别是通过选择一个或多个
          来自 |Sec-WebSocket-Extensions| 的值 场地。这
          没有这样的字段相当于空值。这
          空字符串与这些的空值不同





Fette & Melnikov 标准跟踪 [第 23 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


          目的。客户端未列出的扩展不得为
          列出。选择这些值的方法
          和解释在第 9.1 节中讨论。

   5. 如果服务器选择接受传入的连接，它必须
       回复一个有效的 HTTP 响应，指示以下内容。

       1. 根据RFC 2616
           [ RFC2616 ] ，带有 101 响应代码的状态行。这样的响应可能看起来像“HTTP/1.1 101
           交换协议”。

       2.一次|升级| 根据RFC
           2616 [ RFC2616 ]值为“websocket”的标头字段。

       3. A |连接| 值为“升级”的标头字段。

       4. A |Sec-WebSocket-Accept| 头字段。这的价值
           头域是通过连接/key/来构造的，定义
           以上在第 4.2.2 节的步骤 4 中，使用字符串“258EAFA5-
           E914-47DA-95CA-C5AB0DC85B11"，取这个的 SHA-1 散列
           连接值以获得 20 字节值和 base64-
           编码（参见[RFC4648] 的第 4 节）这个 20 字节的哈希。

           该头域的 ABNF [ RFC2616 ] 定义为
           如下：

           Sec-WebSocket-Accept = base64-value-non-empty
           base64-value-non-empty = (1*base64-data [base64-padding]) |
                                    base64 填充
           base64-data = 4base64-character
           base64-padding = (2base64-character "==") |
                              （3base64 字符“=”）
           base64 字符 = ALPHA | 数字 | "+" | “/”

   注意：例如，如果 |Sec-WebSocket-Key| 的值 标题
   客户端握手中的字段是“dGhlIHNhbXBsZSBub25jZQ==”，
   服务器将附加字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”
   形成字符串“dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-
   C5AB0DC85B11"。然后服务器将采用这个的 SHA-1 哈希
   字符串，给出值 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90
   0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea。这个值
   然后进行 base64 编码，以给出值
   "s3pPLMBiTxaQ9kYGzzhZRbK+xOo="，这将在
   |Sec-WebSocket-接受| 头字段。

       5. 可选的，一个 |Sec-WebSocket-Protocol| 标头字段，带有
           值 /subprotocol/ 在第 4.2.2 节的步骤 4 中定义。




Fette & Melnikov 标准跟踪 [第 24 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


       6. 可选的，一个 |Sec-WebSocket-Extensions| 标头字段，带有
           值 /extensions/ 在第 4.2.2 节的步骤 4 中定义。如果
           要使用多个扩展名，它们都可以列在
           单个 |Sec-WebSocket-Extensions| 标题字段或拆分
           |Sec-WebSocket-Extensions| 的多个实例之间
           头字段。

   这样就完成了服务器的握手。如果服务器完成这些
   不中止 WebSocket 握手的步骤，服务器认为
   要建立的 WebSocket 连接，并且 WebSocket
   连接处于 OPEN 状态。此时，服务器可能会开始
   发送（和接收）数据。

4.3 . 为握手中使用的新标头字段收集 ABNF

   本节使用第 2.1节中的 ABNF 语法/规则
   [RFC2616]，包括“隐含的 *LWS 规则”。

   请注意，本节中使用了以下 ABNF 约定。
   部分规则名称对应对应的名称
   头字段。此类规则表示相应标头的值
   字段，例如 Sec-WebSocket-Key ABNF 规则描述语法
   |Sec-WebSocket-Key| 的 标头字段值。ABNF 规则
   名称中的“-Client”后缀仅用于
   客户端到服务器；带有“-Server”后缀的ABNF规则
   name 仅用于服务器发送给客户端的响应。
   例如，ABNF 规则 Sec-WebSocket-Protocol-Client 描述
   |Sec-WebSocket-Protocol| 的语法 发送的头域值
   客户端到服务器。

   可以在握手期间发送以下新的头字段：
   客户端到服务器：

      Sec-WebSocket-Key = base64-value-non-empty
      Sec-WebSocket-Extensions = 扩展列表
      Sec-WebSocket-Protocol-Client = 1#token
      Sec-WebSocket-Version-Client = 版本

      base64-value-non-empty = (1*base64-data [base64-padding]) |
                                base64 填充
      base64-data = 4base64-character
      base64-padding = (2base64-character "==") |
                         （3base64 字符“=”）
      base64 字符 = ALPHA | 数字 | "+" | “/”
      扩展列表= 1#扩展
      extension = extension-token *( ";" extension-param )
      扩展令牌 = 注册令牌
      注册令牌 = 令牌



Fette & Melnikov 标准跟踪 [第 25 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


      扩展参数=令牌[“=”（令牌|带引号的字符串）]
           ; 使用带引号的字符串语法变体时，值
           ; 引用字符串转义后必须符合
           ; “令牌”ABNF。
      NZDIGIT = "1" | "2" | "3" | “4” | “5” | "6" |
                       "7" | "8" | “9”
      版本 = 数字 | (NZDIGIT 数字) |
                （“1”位数字） | （“2”位数字）
                ; 限于 0-255 范围，没有前导零

   可以在握手期间发送以下新的头字段：
   服务器到客户端：

      Sec-WebSocket-Extensions = 扩展列表
      Sec-WebSocket-Accept = base64-value-non-empty
      Sec-WebSocket-Protocol-Server = 令牌
      Sec-WebSocket-Version-Server = 1#version

4.4 . 支持多版本的WebSocket协议

   本节提供了有关支持多个版本的一些指导
   客户端和服务器中的 WebSocket 协议。

   使用 WebSocket 版本广告功能（
   |Sec-WebSocket-版本| 标头字段），客户端最初可以请求
   它喜欢的 WebSocket 协议的版本（不
   必须是客户端支持的最新版本）。如果
   服务器支持请求的版本并且握手消息是
   否则有效，服务器将接受该版本。如果服务器
   不支持请求的版本，它必须响应
   |Sec-WebSocket-版本| 标头字段（或多个
   |Sec-WebSocket-版本| 标头字段）包含它的所有版本
   愿意使用。此时，如果客户端支持其中之一
   广告版本，它可以使用重复 WebSocket 握手
   新版本值。

   以下示例演示了描述的版本协商
   以上：

      获取/聊天 HTTP/1.1
      主机：server.example.com
      升级：websocket
      连接：升级
      ...
      Sec-WebSocket-版本：25






Fette & Melnikov 标准跟踪 [第 26 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   来自服务器的响应可能如下所示：

      HTTP/1.1 400 错误请求
      ...
      Sec-WebSocket-Version: 13, 8, 7

   请注意，来自服务器的最后响应也可能如下所示：

      HTTP/1.1 400 错误请求
      ...
      Sec-WebSocket-版本：13
      Sec-WebSocket-Version: 8, 7

   客户端现在重复符合版本 13 的握手：

      获取/聊天 HTTP/1.1
      主机：server.example.com
      升级：websocket
      连接：升级
      ...
      Sec-WebSocket-版本：13

5 . 数据框架

5.1 . 概述

   在 WebSocket 协议中，数据是使用一系列的
   帧。为避免混淆网络中介（如
   拦截代理）和出于安全原因，进一步
   在第 10.3 节中讨论过，客户端必须屏蔽它的所有帧
   发送到服务器（有关详细信息，请参阅第 5.3 节）。（笔记
   无论 WebSocket 协议是否正在运行，都会完成屏蔽
   通过 TLS。）服务器必须在收到一个
   未屏蔽的框架。在这种情况下，服务器可以发送关闭
   状态码为 1002（协议错误）的帧，定义在
   第 7.4.1 节。服务器不得屏蔽它发送到的任何帧
   客户端。如果客户端检测到一个被屏蔽的连接，它必须关闭一个连接
   框架。在这种情况下，它可以使用状态代码 1002（协议
   错误）如第 7.4.1 节中所定义。（这些规则可能会在
   未来的规范。）

   基本帧协议定义了一个带有操作码的帧类型，一个
   有效载荷长度，以及“扩展数据”的指定位置和
   “应用程序数据”，它们共同定义了“有效载荷数据”。
   某些位和操作码保留用于未来的扩展
   协议。





Fette & Melnikov 标准跟踪 [第 27 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   数据帧可以由客户端或服务器传输
   打开握手完成后和该端点之前的任何时间
   已发送关闭帧（第 5.5.1 节）。

5.2 . 基本帧协议

   数据传输部分的这种有线格式由 ABNF 描述
   [ RFC5234 ] 本节详细给出。（请注意，与
   本文档的其他部分，本部分中的 ABNF 是
   对位组进行操作。每组位的长度为
   在评论中指出。当在电线上编码时，最
   有效位是 ABNF 中的最左边）。高级概述
   框架结构如下图所示。在的情况下
   下图与后面指定的 ABNF 之间的冲突
   这一段，图是权威的。

      0 1 2 3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-------+-+------------+-- --------------+
     |F|R|R|R| 操作码|M| 有效载荷长度 | 扩展的有效载荷长度 |
     |I|S|S|S| (4) |A| (7) | (16/64) |
     |N|V|V|V| |S| | (如果有效载荷 len==126/127) |
     | |1|2|3| |K| | |
     +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
     | 扩展有效载荷长度继续，如果有效载荷 len == 127 |
     + - - - - - - - - - - - - - - - +-------------------------------+
     | |屏蔽键，如果 MASK 设置为 1 |
     +-------------------------------+----------------- --------------+
     | 掩码键（续） | 有效载荷数据 |
     +-------------------------------- - - - - - - - - - - - - - - - +
     ：有效载荷数据继续......：
     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
     | 有效载荷数据继续... |
     +------------------------------------------------- --------------+

   鳍：1位

      表示这是消息中的最后一个片段。首先
      片段也可能是最终片段。

   RSV1、RSV2、RSV3：各 1 位

      必须为 0，除非协商了定义含义的扩展
      对于非零值。如果接收到非零值并且没有
      协商的扩展定义了这种非零的含义
      值，接收端点必须 _Fail WebSocket
      联系_。




Fette & Melnikov 标准跟踪 [第 28 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   操作码：4位

      定义“有效载荷数据”的解释。如果一个未知
      接收到操作码，接收端点必须 _Fail
      WebSocket 连接_。定义了以下值。

      * %x0 表示继续帧

      * %x1 表示文本框

      * %x2 表示一个二进制帧

      * %x3-7 保留用于进一步的非控制帧

      * %x8 表示连接关闭

      * %x9 表示 ping

      * %xA 表示乒乓球

      * %xB-F 保留用于进一步的控制帧

   掩码：1位

      定义是否屏蔽“有效载荷数据”。如果设置为 1，一个
      掩码键存在于掩码键中，这用于取消掩码
      根据第 5.3 节的“有效载荷数据” 。发送的所有帧
      客户端到服务器将此位设置为 1。

   有效载荷长度：7 位、7+16 位或 7+64 位

      “Payload data”的长度，以字节为单位：如果0-125，就是
      有效载荷长度。如果为 126，则以下 2 个字节解释为
      16 位无符号整数是有效载荷长度。如果 127，则
      以下 8 个字节被解释为一个 64 位无符号整数（
      最高有效位必须为 0）是有效载荷长度。多字节
      长度量以网络字节顺序表示。注意
      在所有情况下，必须使用最少的字节数来编码
      长度，例如 124 字节长的字符串的长度
      不能编码为序列 126, 0, 124. 有效载荷长度
      是“扩展数据”的长度+
      “应用数据”。“扩展数据”的长度可能是
      零，在这种情况下，有效载荷长度是
      “应用数据”。







Fette & Melnikov 标准跟踪 [第 29 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   掩码密钥：0 或 4 个字节

      从客户端发送到服务器的所有帧都被一个
      包含在帧中的 32 位值。这个字段是
      如果掩码位设置为 1，则存在，如果掩码位，则不存在
      设置为 0。有关客户端的更多信息，请参见第 5.3 节
      到服务器屏蔽。

   有效载荷数据：(x+y) 字节

      “有效载荷数据”被定义为“扩展数据”串联
      与“应用程序数据”。

   扩展数据：x 字节

      “扩展数据”是 0 字节，除非扩展已经
      协商。任何扩展必须指定长度
      “扩展数据”，或如何计算该长度，以及如何
      必须在开始握手期间协商扩展使用。
      如果存在，“扩展数据”包含在总有效载荷中
      长度。

   应用数据：y 字节

      任意“应用数据”，占据帧的其余部分
      在任何“扩展数据”之后。“应用程序数据”的长度
      等于有效载荷长度减去“扩展”的长度
      数据”。

   基本成帧协议由以下 ABNF 正式定义
   [ RFC5234 ]。重要的是要注意，这个表示
   数据是二进制的，而不是 ASCII 字符。因此，具有长度的字段
   取值为 %x0 / %x1 的 1 位表示为单个位
   其值为 0 或 1，而不是代表
   ASCII 编码中的字符“0”或“1”。有长度的字段
   值在 %x0-F 之间的 4 位再次由 4 位表示，
   再次不是 ASCII 字符或全字节（八位字节）与这些
   值。[ RFC5234 ] 没有指定字符编码：“规则
   解析为一串终端值，有时称为
   人物。在 ABNF 中，字符只是一个非负整数。
   在某些情况下，值的特定映射（编码）到
   字符集（如 ASCII）将被指定。”这里，
   指定的编码是二进制编码，其中每个终端值是
   以指定的位数编码，每个字段都不同。







Fette & Melnikov 标准跟踪 [第 30 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


    ws-frame = 框架鳍；1 位长
                              帧-rsv1 ; 1 位长
                              帧-rsv2 ; 1 位长
                              帧-rsv3 ; 1 位长
                              帧操作码；4位长
                              框架屏蔽；1 位长
                              帧有效载荷长度；7, 7+16,
                                                     ; 或 7+64 位输入
                                                     ; 长度
                              [ 帧掩码键 ] ; 32位长
                              帧有效载荷数据；n*8 位输入
                                                     ; 长度，其中
                                                     ; n >= 0

    框架鳍 = %x0 ; 此消息的更多帧如下
                            /%x1; 此消息的最后一帧
                                  ; 1 位长

    帧-rsv1 = %x0 / %x1
                              ; 1 位长度，必须为 0，除非
                              ; 另行协商

    帧-rsv2 = %x0 / %x1
                              ; 1 位长度，必须为 0，除非
                              ; 另行协商

    帧-rsv3 = %x0 / %x1
                              ; 1 位长度，必须为 0，除非
                              ; 另行协商

    帧操作码 = 帧操作码非控制 /
                              帧操作码控制 /
                              帧操作码连续

    帧操作码连续 = %x0 ; 帧延续

    帧操作码非控制= %x1 ; 文本框
                            / %x2 ; 二进制帧
                            / %x3-7
                            ; 长度为 4 位，
                            ; 保留用于进一步的非控制帧

    帧操作码控制 = %x8 ；连接关闭
                            / %x9 ; 平
                            /%xA ; 乒乓球
                            / %xB-F ; 保留用于进一步控制
                                    ; 框架
                                    ; 4位长



Fette & Melnikov 标准跟踪 [第 31 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


    帧屏蔽 = %x0
                            ; 框架没有被屏蔽，没有框架屏蔽键
                            / %x1
                            ; 框架被屏蔽，存在框架屏蔽键
                            ; 1 位长

    帧有效载荷长度 = ( %x00-7D )
                            / ( %x7E 帧有效载荷长度-16 )
                            / ( %x7F 帧有效载荷长度-63 )
                            ; 7、7+16 或 7+64 位长度，
                            ; 分别

    帧有效载荷长度-16 = %x0000-FFFF ；16 位长

    帧有效载荷长度-63 = %x0000000000000000-7FFFFFFFFFFFFFF
                            ; 64位长

    帧屏蔽键 = 4（%x00-FF）
                              ; 仅当 frame-masked 为 1 时存在
                              ; 32位长

    frame-payload-data = (frame-masked-extension-data
                               框架屏蔽应用程序数据）
                            ; 当 frame-masked 为 1 时
                              / (frame-unmasked-extension-data
                                框架未屏蔽应用程序数据）
                            ; 当 frame-masked 为 0 时

    框架屏蔽扩展数据 = *( %x00-FF )
                            ; 为将来的可扩展性保留
                            ; 长度为 n*8 位，其中 n >= 0

    框架屏蔽应用程序数据 = *( %x00-FF )
                            ; 长度为 n*8 位，其中 n >= 0

    框架未屏蔽扩展数据 = *( %x00-FF )
                            ; 为将来的可扩展性保留
                            ; 长度为 n*8 位，其中 n >= 0

    框架未屏蔽应用程序数据 = *( %x00-FF )
                            ; 长度为 n*8 位，其中 n >= 0

5.3 . 客户端到服务器屏蔽

   屏蔽帧必须将字段 frame-masked 设置为 1，如定义
   在第 5.2 节中。





Fette & Melnikov 标准跟踪 [第 32 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   掩码键完全包含在框架内，如定义
   在第 5.2 节中作为 frame-masking-key。它用于屏蔽“有效载荷
   data”在与 frame-payload-data 相同的部分中定义，其中
   包括“扩展数据”和“应用程序数据”。

   掩码密钥是客户端随机选择的 32 位值。
   准备蒙版帧时，客户端必须选择新的蒙版
   来自允许的 32 位值集合的键。掩码键需要
   不可预测；因此，掩码密钥必须来自强
   熵源和给定​​帧的掩码键不得
   使服务器/代理预测掩码密钥变得简单
   后续帧。掩码密钥的不可预测性是
   防止恶意应用程序的作者选择
   出现在线路上的字节。  RFC 4086 [ RFC4086 ] 讨论了什么
   需要一个适合安全敏感的熵源
   应用程序。

   屏蔽不会影响“有效载荷数据”的长度。到
   将屏蔽数据转换为非屏蔽数据，反之亦然，如下
   算法被应用。相同的算法适用于
   翻译的方向，例如，相同的步骤应用于
   屏蔽数据以取消屏蔽数据。

   转换后的数据（“transformed-octet-i”）的八位字节 i 是
   原始数据的八位字节 i（“original-octet-i”），索引处为八位字节
   我对掩码密钥 ("masking-key-octet-j") 取模 4：

     j = i MOD 4
     变换的八位组-i = 原始的八位组-i XOR 掩码-键-八位组-j

   有效载荷长度，在帧中表示为 frame-payload-length，
   不包括屏蔽键的长度。它的长度为
   “有效载荷数据”，例如屏蔽后的字节数
   钥匙。

5.4 . 碎片化

   分片的主要目的是允许发送消息
   当消息开始时大小未知，而不必
   缓冲该消息。如果消息不能被分段，那么
   端点必须缓冲整个消息，以便其长度可以
   在发送第一个字节之前进行计数。随着碎片化，一个
   服务器或中介可以选择一个合理大小的缓冲区，当
   缓冲区已满，将片段写入网络。

   分片的第二个用例是多路复用，它
   对于一个逻辑通道上的大消息来说是不可取的
   独占输出通道，所以复用需要空闲



Fette & Melnikov 标准跟踪 [第 33 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   将消息拆分为更小的片段以更好地共享
   输出通道。（注意复用扩展不是
   本文档中描述。）

   除非扩展另有规定，否则帧没有语义
   意义。如果没有，中介可能会合并和/或拆分帧
   扩展由客户端和服务器协商，或者如果一些
   谈判延期，但中介了解所有
   扩展协商并知道如何合并和/或拆分帧
   在存在这些扩展的情况下。这其中的一个含义是
   在没有扩展的情况下，发送方和接收方不得依赖
   特定帧边界的存在。

   以下规则适用于分片：

   o 未分片的消息由一个带有 FIN 的帧组成
      位集（第 5.2 节）和非 0 的操作码。

   o 一个分段的消息由一个带有 FIN 位的帧组成
      清除和非 0 的操作码，后跟零个或多个帧
      FIN 位清零，操作码设置为 0，并终止于
      设置了 FIN 位且操作码为 0 的单个帧。 A
      碎片化的消息在概念上等同于一个更大的
      其有效载荷等于连接的消息
      片段的有效载荷按顺序；然而，在有
      扩展，这可能不成立，因为扩展定义了
      对当前“扩展数据”的解释。例如，
      “扩展数据”可能只出现在第一个的开头
      片段并应用于后续片段，或者可能有
      每个适用的片段中都存在“扩展数据”
      只到那个特定的片段。在没有“扩展
      数据”，下面的例子演示了碎片是如何工作的。

      示例：对于作为三个片段发送的文本消息，第一个
      片段将有一个 0x1 的操作码和一个 FIN 位清除，
      第二个片段将有一个 0x0 的操作码和一个 FIN 位清除，
      第三个片段的操作码为 0x0 和一个 FIN 位
      那是设置。

   o 控制帧（见第 5.5 节）可以在中间注入
      碎片化的消息。控制帧本身不得
      支离破碎。

   o 消息片段必须按顺序传递给接收者
      由发件人发送。






Fette & Melnikov 标准跟踪 [第 34 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   o 一条消息的片段不得在消息之间交错
      另一条消息的片段，除非扩展已被
      协商，可以解释交错。

   o 端点必须能够处理控制帧
      碎片消息的中间。

   o 发送者可以为非控制创建任意大小的片段
      消息。

   o 客户端和服务器必须支持接收分片和
      未分片的消息。

   o 由于控制帧不能被分片，中间人不得
      尝试改变控制帧的碎片。

   o 中介不得更改消息的分段，如果
      使用任何保留位值以及这些值的含义
      中介不知道。

   o 中介不得更改任何消息的分片
      在扩展已被连接的上下文中
      协商并且中介不知道语义
      协商的延期。同样，一个没有
      看到 WebSocket 握手（并且没有被通知它的
      内容）导致 WebSocket 连接不得更改
      这种连接的任何消息的碎片。

   o 由于这些规则，消息的所有片段都属于
      相同的类型，由第一个片段的操作码设置。自从
      控制帧不能分片，所有分片的类型
      消息必须是文本、二进制或保留的其中之一
      操作码。

   注意：如果无法插入控制帧，则延迟
   例如，如果在大消息后面，ping 会很长。
   因此，需要在中间处理控制帧
   碎片化的消息。

   实施说明：在没有任何分机的情况下，接收器
   不必缓冲整个帧来处理它。为了
   例如，如果使用流式 API，则帧的一部分可以
   交付给应用程序。但是，请注意，此假设
   可能不适用于所有未来的 WebSocket 扩展。







Fette & Melnikov 标准跟踪 [第 35 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


5.5 . 控制帧

   控制帧由操作码标识，其中最重要的
   操作码的位为 1。当前为控制帧定义的操作码
   包括 0x8（关闭）、0x9（Ping）和 0xA（Pong）。操作码 0xB-0xF 是
   保留用于尚未定义的进一步控制帧。

   控制帧用于传达有关 WebSocket 的状态。
   控制帧可以插入到碎片的中间
   信息。

   所有控制帧的有效载荷长度必须为 125 字节或更少
   并且不得碎片化。

5.5.1 . 关闭

   Close 帧包含一个 0x8 的操作码。

   关闭框架可以包含一个主体（“应用程序数据”部分
   帧）表示关闭的原因，例如端点
   正在关闭、端点接收到过大的帧，或
   端点收到了不符合格式的帧
   端点所期望的。如果有正文，则前两个字节
   主体必须是一个 2 字节的无符号整数（按网络字节顺序）
   表示状态代码，其值为 /code/ 定义在第 7.4 节。
   在 2 字节整数之后，主体可能包含 UTF-8 编码的数据
   值/reason/，其解释未定义
   本规范。这些数据不一定是人类可读的，但
   可能有助于调试或传递与
   打开连接的脚本。由于数据不能保证
   是人类可读的，客户端不得将其显示给最终用户。

   从客户端发送到服务器的关闭帧必须按照
   第 5.3 节。

   应用程序在发送一个
   关闭框架。

   如果端点接收到关闭帧并且之前没有发送过
   关闭帧，端点必须发送一个关闭帧作为响应。（什么时候
   发送一个关闭帧作为响应，端点通常回应
   它收到的状态代码。）它应该尽快这样做。一个
   端点可以延迟发送一个关闭帧，直到它的当前消息被
   已发送（例如，如果碎片消息的大部分是
   已经发送，端点可以在之前发送剩余的片段
   发送关闭帧）。但是，不能保证
   已经发送关闭帧的端点将继续处理
   数据。



Fette & Melnikov 标准跟踪 [第 36 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   在发送和接收关闭消息后，端点
   认为 WebSocket 连接已关闭并且必须关闭
   底层 TCP 连接。服务器必须关闭底层 TCP
   立即连接；客户端应该等待服务器
   关闭连接但可以在之后的任何时间关闭连接
   发送和接收关闭消息，例如，如果它没有收到
   TCP 在合理的时间段内从服务器关闭。

   如果客户端和服务器同时发送关闭消息，
   两个端点都将发送和接收关闭消息，并且应该
   考虑关闭 WebSocket 连接并关闭底层 TCP
   联系。

5.5.2 . 平

   Ping 帧包含一个 0x9 的操作码。

   Ping 帧可以包括“应用程序数据”。

   收到 Ping 帧后，端点必须发送 Pong 帧
   响应，除非它已经收到关闭帧。这应该
   尽快回复 Pong 框架。乒乓球框是第 5.5.3 节中
   讨论过。

   端点可以在连接结束后的任何时间发送 Ping 帧
   建立并在连接关闭之前。

   注意：Ping 帧既可以作为保活，也可以作为一种手段
   验证远程端点是否仍然响应。

5.5.3 . 乒乓

   Pong 帧包含 0xA 的操作码。

   第 5.5.2 节详细说明了适用于乒乓和乒乓的要求
   帧。

   响应 Ping 帧而发送的 Pong 帧必须具有相同的
   在 Ping 帧的消息正文中找到的“应用程序数据”
   被回复。

   如果端点收到 Ping 帧但尚未发送 Pong
   帧响应前一个 Ping 帧，端点可以
   选择只为最近处理的 Ping 发送 Pong 帧
   框架。






Fette & Melnikov 标准跟踪 [第 37 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   Pong 帧可以不请自来地发送。这作为一个
   单向心跳。对主动提供的 Pong 帧的响应是
   没想到。

5.6 . 数据帧

   数据帧（例如，非控制帧）由操作码标识
   其中操作码的最高有效位是 0。当前定义
   数据帧的操作码包括 0x1（文本）、0x2（二进制）。操作码
   0x3-0x7 保留用于进一步的非控制帧
   定义。

   数据帧承载应用层和/或扩展层数据。这
   操作码决定数据的解释：

   文本

      “有效载荷数据”是编码为 UTF-8 的文本数据。请注意，一个
      特定的文本框可能包含部分 UTF-8 序列；
      但是，整个消息必须包含有效的 UTF-8。无效的
      重组消息中的 UTF-8 处理如
      第 8.1 节。

   二进制

      “有效载荷数据”是任意二进制数据，其解释
      完全取决于应用层。

5.7 . 例子

   o 单帧无掩码短信

      * 0x81 0x05 0x48 0x65 0x6c 0x6c 0x6f（包含“你好”）

   o 单帧屏蔽短信

      * 0x81 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58
         （包含“你好”）

   o 碎片化的未屏蔽短信

      * 0x01 0x03 0x48 0x65 0x6c（包含“Hel”）

      * 0x80 0x02 0x6c 0x6f（包含“lo”）







Fette & Melnikov 标准跟踪 [第 38 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   o 未屏蔽的 Ping 请求和屏蔽的 Ping 响应

      * 0x89 0x05 0x48 0x65 0x6c 0x6c 0x6f（包含“Hello”的主体，
         但正文的内容是任意的）

      * 0x8a 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58
         （包含“Hello”的正文，与ping的正文匹配）

   o 单个未屏蔽帧中的 256 字节二进制消息

      * 0x82 0x7E 0x0100 [256 字节二进制数据]

   o 单个未屏蔽帧中的 64KiB 二进制消息

      * 0x82 0x7F 0x0000000000010000 [65536 字节的二进制数据]

5.8 . 可扩展性

   该协议旨在允许扩展，这将增加
   基本协议的能力。连接的端点
   必须在开幕期间协商使用任何延期
   握手。该规范提供了 0x3 到 0x7 的操作码和
   0xB 到 0xF、“扩展数据”字段和帧 rsv1，
   帧头的 frame-rsv2 和 frame-rsv3 位供
   扩展名。延期谈判将在进一步讨论
   详情见第 9.1 节。以下是一些预期用途
   扩展名。此列表既不完整也不规范。

   o “扩展数据”可以放在“有效载荷数据”之前
      “应用数据”。

   o 可以为每帧需要分配保留位。

   o 可以定义保留的操作码值。

   o 如果有更多操作码，可以将保留位分配给操作码字段
      值是需要的。

   o 保留位或“扩展”操作码可以定义为
      从“有效载荷数据”中分配额外的位来定义
      更大的操作码或更多的每帧位。

6 . 发送和接收数据

6.1 . 发送数据

   通过 WebSocket _发送包含 /data/ 的 WebSocket 消息_
   连接，端点必须执行以下步骤。



Fette & Melnikov 标准跟踪 [第 39 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   1. 端点必须确保 WebSocket 连接在 OPEN 中
       状态（参见第4.1和4.2.2节。）如果在任何时候
       WebSocket 连接更改，端点必须中止
       以下步骤。

   2. 端点必须将 /data/ 封装在 WebSocket 框架中，如
       在第 5.2 节中定义。如果要发送的数据很大或者
       数据不完整
       端点希望开始发送数据，端点可以
       交替地将数据封装在定义的一系列帧中
       在第 5.4 节中。

   3.包含数据的第一帧的操作码（frame-opcode）
       必须为数据设置为第 5.2 节中的适当值
       收件人将其解释为文本或二进制
       数据。

   4. 包含数据的最后一帧的 FIN 位（frame-fin）
       必须按照第 5.2 节中的定义设置为 1 。

   5. 如果客户端正在发送数据，则帧必须是
       按照第 5.3 节中的定义进行屏蔽。

   6. 如果任何延期（第 9 节）已经协商
       WebSocket 连接，其他注意事项可能适用
       这些扩展的定义。

   7. 已经形成的帧必须通过
       底层网络连接。

6.2 . 接收数据

   为了接收 WebSocket 数据，端点侦听底层
   网络连接。传入的数据必须被解析为 WebSocket 帧
   如第 5.2 节中所定义。如果控制帧（第 5.5 节）是
   收到后，必须按照第 5.5 节的定义处理该帧。之上
   接收数据帧（第 5.6 节），端点必须注意
   /type/ 由操作码（帧操作码）定义的数据来自
   第 5.2 节。此框架中的“应用程序数据”定义为
   消息的 /data/。如果该帧包含未分片的
   消息（第 5.4 节），据说_A WebSocket Message Has been
   Received_ 类型为 /type/ 和数据 /data/。如果框架是
   一个碎片化的消息，后续数据的“应用数据”
   帧被连接起来形成 /data/。当最后一个片段是
   接收到由 FIN 位 (frame-fin) 指示的，据说 _A
   WebSocket 消息已收到_带有数据 /data/（由
   片段的“应用程序数据”的串联）和




Fette & Melnikov 标准跟踪 [第 40 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   键入 /type/（从分段消息的第一帧中注意到）。
   随后的数据帧必须被解释为属于一个新的
   WebSocket 消息。

   扩展（第 9 节）可能会改变数据读取方式的语义，
   特别包括构成消息边界的内容。
   扩展，除了在前面添加“扩展数据”
   有效载荷中的“应用程序数据”，也可以修改“应用程序数据”
   数据”（例如通过压缩它）。

   服务器必须删除从客户端接收到的数据帧的掩码
   如第 5.3 节所述。

7 . 关闭连接

7.1 . 定义

7.1.1 . 关闭 WebSocket 连接

   要_关闭 WebSocket 连接_，端点会关闭
   底层 TCP 连接。端点应该使用一种方法
   干净地关闭 TCP 连接以及 TLS 会话，如果
   适用，丢弃可能已被删除的任何尾随字节
   已收到。端点可以通过任何方式关闭连接
   必要时可用，例如在受到攻击时。

   底层的 TCP 连接，在大多数正常情况下，应该关闭
   首先由服务器，以便它保持 TIME_WAIT 状态而不是
   客户端（因为这会阻止它重新打开连接 2
   最大段寿命 (2MSL)，而没有相应的
   服务器影响，因为 TIME_WAIT 连接立即重新打开
   具有更高序列号的新 SYN）。在异常情况下（如不
   在合理数量后从服务器收到 TCP 关闭
   时间）客户端可以发起 TCP 关闭。因此，当服务器
   指示_关闭 WebSocket 连接_它应该启动
   TCP 立即关闭，当客户端被指示执行
   同样，它应该等待来自服务器的 TCP 关闭。

   作为如何使用 Berkeley 在 C 中获得干净闭包的示例
   套接字，可以在套接字上使用 SHUT_WR 调用 shutdown()，调用
   recv() 直到获得返回值 0 表示对端
   也执行了有序关闭，最后调用close() on
   插座。








Fette & Melnikov 标准跟踪 [第 41 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


7.1.2 . 启动 WebSocket 关闭握手

   使用状态代码 _Start the WebSocket Closing Handshake_
   （第 7.4 节） /code/ 和一个可选的关闭原因（第 7.1.6 节）
   /reason/，端点必须发送一个关闭控制帧，如描述
   在第 5.5.1 节中，其状态代码设置为 /code/ 并且其关闭
   原因设置为 /reason/。一旦端点同时发送和
   收到一个关闭控制帧，该端点应该_关闭第 7.1.1 节中
   定义的 WebSocket Connection_ 。

7.1.3 . WebSocket 关闭握手开始

   在发送或接收关闭控制帧时，说
   _The WebSocket Closing Handshake is Started_并且
   WebSocket 连接处于 CLOSING 状态。

7.1.4 . WebSocket 连接已关闭

   当底层的 TCP 连接关闭时，据说_
   WebSocket 连接已关闭_并且 WebSocket 连接是
   处于关闭状态。如果 TCP 连接在
   WebSocket关闭握手完成，WebSocket连接
   据说已经_cleanly_关闭了。

   如果无法建立 WebSocket 连接，也是说
   _WebSocket 连接已关闭_，但不是 _cleanly_。

7.1.5 . WebSocket 连接关闭代码

   如第5.5.1节和第7.4节中所定义，关闭控制框架可以
   包含指示关闭原因的状态代码。关闭
   WebSocket 连接可以由任一端点发起，
   可能同时。_WebSocket 连接关闭代码_是
   定义为第一个 Close 中包含的状态代码（第 7.4 节）
   实现该协议的应用程序接收到的控制帧。
   如果这个关闭控制帧不包含状态码，_WebSocket
   连接关闭代码_被认为是1005。如果_WebSocket
   连接已关闭_并且没有收到关闭控制帧
   端点（例如，如果底层传输连接
   丢失），_WebSocket连接关闭代码_被认为是
   1006.

   注意：两个端点可能不同意_The WebSocket 的值
   连接关闭代码_。例如，如果远程端点发送了一个
   关闭框架但本地应用程序尚未读取数据
   包含来自其套接字接收缓冲区的关闭帧，以及
   本地应用程序独立决定关闭连接并
   发送一个关闭帧，两个端点都将发送和接收一个



Fette & Melnikov 标准跟踪 [第 42 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   关闭帧并且不会发送更多的关闭帧。每个端点
   会看到另一端发送的状态码为_The WebSocket
   连接关闭代码_。如此一来，两人有可能
   端点可能不同意 _WebSocket 连接的值
   两个端点都关闭代码_启动WebSocket
   独立且大致同时关闭 Handshake_。

7.1.6 . WebSocket 连接关闭原因

   如第5.5.1节和第7.4节中所定义，关闭控制框架可以
   包含指示关闭原因的状态代码，后跟
   UTF-8 编码的数据，所述数据的解释由
   端点而不是由本协议定义。关闭
   WebSocket 连接可以由任一端点发起，可能
   同时。_WebSocket 连接关闭原因_定义为
   状态代码后的 UTF-8 编码数据（第 7.4 节）
   包含在第一个 Close 控制帧中
   实现此协议的应用程序。如果没有这样的数据
   Close控制框架，_WebSocket连接关闭原因_是
   空字符串。

   注意：按照第 7.1.5 节中提到的相同逻辑，两个
   端点可能不同意_WebSocket 连接关闭原因_。

7.1.7 . 使 WebSocket 连接失败

   某些算法和规范需要一个端点来 _Fail
   WebSocket 连接_。为此，客户端必须_关闭
   WebSocket Connection_，并且可以将问题报告给用户（其中
   以适当的方式对开发人员特别有用）。
   同样，为此，服务器必须_关闭 WebSocket
   Connection_，并且应该记录问题。

   如果 _WebSocket 连接已建立_ 在该点之前
   端点需要_使 WebSocket 连接失败_，
   端点应该发送一个带有适当状态代码的关闭帧
   （第 7.4 节）在继续_关闭 WebSocket 连接_之前。
   如果端点相信另一个端点，则它可以省略发送关闭帧
   侧不太可能能够接收和处理关闭帧，
   由于导致 WebSocket 连接到的错误的性质
   首先失败。端点不得继续尝试
   从远程处理数据（包括响应关闭帧）
   被指示_使 WebSocket 连接失败_后的端点。

   除非如上所示或应用层指定
   （例如，使用 WebSocket API 的脚本），客户端不应该关闭
   连接。




Fette & Melnikov 标准跟踪 [第 43 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


7.2 . 异常关闭

7.2.1 . 客户发起的关闭

   某些算法，特别是在开始握手期间，
   要求客户端_使 WebSocket 连接失败_。为此，该
   客户端必须_失败 WebSocket 连接_，如定义
   第 7.1.7 节。

   如果在任何时候底层传输层连接是
   意外丢失，客户端必须_使 WebSocket 连接失败_。

   除非如上所示或应用层指定
   （例如，使用 WebSocket API 的脚本），客户端不应该关闭
   连接。

7.2.2 . 服务器启动的关闭

   某些算法要求或建议服务器 _Abort
   开始握手期间的 WebSocket Connection_。为此，该
   服务器必须简单地_关闭 WebSocket 连接_（第 7.1.1 节）。

7.2.3 . 从异常关闭中恢复

   异常关闭可能由多种原因引起。这样的
   闭包可能是暂时性错误的结果，在这种情况下
   重新连接可能会导致连接良好并恢复正常
   操作。这种关闭也可能是非瞬态的结果
   问题，在这种情况下，如果每个部署的客户端都遇到
   异常关闭并立即并持续尝试重新连接，
   服务器可能会遇到相当于拒绝服务的攻击
   大量客户端尝试重新连接。最终结果
   这种情况可能是服务无法在
   及时处理或恢复变得更加困难。

   为了防止这种情况，客户端应该在尝试时使用某种形式的退避
   如本节所述，在异常关闭后重新连接。

   第一次重新连接尝试应该被随机延迟
   时间。选择这个随机延迟的参数被留下
   由客户决定；在 0 到 5 之间随机选择的值
   秒是合理的初始延迟，尽管客户可以选择
   根据不同的间隔选择延迟长度
   实施经验和具体应用。

   如果第一次重新连接尝试失败，后续重新连接
   尝试应该被延迟越来越长的时间，
   使用诸如截断二进制指数退避之类的方法。



Fette & Melnikov 标准跟踪 [第 44 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


7.3 . 正常关闭连接

   服务器可以在需要时关闭 WebSocket 连接。客户
   不应随意关闭 WebSocket 连接。在任一
   在这种情况下，端点通过遵循以下程序来启动关闭
   _启动 WebSocket 关闭握手_（第 7.1.2 节）。

7.4 . 状态代码

   当关闭一个已建立的连接时（例如，当发送一个 Close
   帧，在打开握手完成后），一个端点可以
   说明关闭的原因。对这个原因的解释
   一个端点，以及端点应该采取的行动
   原因，本规范未定义。本规范
   定义一组预定义的状态代码并指定范围
   可由扩展、框架和终端应用程序使用。这
   状态代码和任何相关的文本消息是可选的
   关闭框架的组件。

7.4.1 . 定义的状态代码

   端点可以在发送时使用以下预定义的状态代码
   关闭框架。

   1000

      1000 表示正常关闭，这意味着
      已建立的连接已完成。

   1001

      1001 表示端点正在“离开”，例如服务器
      下降或浏览器导航离开页面。

   1002

      1002 表示端点正在终止连接
      到协议错误。

   1003

      1003 表示端点正在终止连接
      因为它收到了一种它不能接受的数据类型（例如，一个
      仅理解文本数据的端点可能会发送它，如果它
      收到一个二进制消息）。






Fette & Melnikov 标准跟踪 [第 45 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   1004

      预订的。具体含义可能会在以后定义。

   1005

      1005 是一个保留值，不得在
      通过端点关闭控制帧。它被指定用于
      需要状态代码来指示没有状态的应用程序
      代码实际上存在。

   1006

      1006 是一个保留值，不得在
      通过端点关闭控制帧。它被指定用于
      应用程序需要一个状态代码来表明
      连接异常关闭，例如，没有发送或
      接收关闭控制帧。

   1007

      1007 表示端点正在终止连接
      因为它收到了一条消息中的数据，而不是
      与消息类型一致（例如，非 UTF-8 [ RFC3629 ]
      文本消息中的数据）。

   1008

      1008 表示端点正在终止连接
      因为它收到了一条违反其政策的消息。这个
      是一个通用状态码，当没有时可以返回
      其他更合适的状态代码（例如，1003 或 1009）或者如果有
      需要隐藏有关政策的具体细节。

   1009

      1009 表示端点正在终止连接
      因为它收到了一个太大的消息
      过程。

   1010

      1010 表示端点（客户端）正在终止
      连接，因为它期望服务器协商一个或
      更多扩展名，但服务器没有在响应中返回它们
      WebSocket 握手的消息。扩展名列表





Fette & Melnikov 标准跟踪 [第 46 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


      are required 应该出现在 Close 框架的 /reason/ 部分。
      请注意，服务器不使用此状态代码，因为它
      可能会导致 WebSocket 握手失败。

   1011

      1011 表示服务器正在终止连接，因为
      它遇到了一个意外情况，阻止了它
      满足请求。

   1015

      1015 是一个保留值，不得在
      通过端点关闭控制帧。它被指定用于
      应用程序需要一个状态代码来表明
      由于执行 TLS 握手失败，连接被关闭
      （例如，无法验证服务器证书）。

7.4.2 . 保留状态代码范围

   0-999

      不使用 0-999 范围内的状态代码。

   1000-2999

      1000-2999 范围内的状态代码保留用于定义
      本协议及其未来的修订版和扩展
      永久且随时可用的公共规范。

   3000-3999

      3000-3999 范围内的状态代码保留供
      库、框架和应用程序。这些状态代码是
      直接在 IANA 注册。这些代码的解释
      本协议未定义。

   4000-4999

      4000-4999 范围内的状态代码保留供私人使用
      因此无法注册。这些代码可以由先前的
      WebSocket 应用程序之间的协议。的解释
      本协议未定义这些代码。








Fette & Melnikov 标准跟踪 [第 47 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


8 . 错误处理

8.1 . 处理 UTF-8 编码数据中的错误

   当端点将字节流解释为 UTF-8 但发现
   字节流实际上不是有效的 UTF-8 流，即
   端点必须_使 WebSocket 连接失败_。此规则适用
   在开始握手期间和随后的数据期间
   交换。

9 . 扩展

   WebSocket 客户端可以请求对此规范的扩展，并且
   WebSocket 服务器可以接受部分或所有扩展请求
   客户。服务器不得以未请求的任何扩展响应
   由客户。如果协商中包含扩展参数
   在客户端和服务器之间，这些参数必须在
   根据扩展的规范
   参数适用。

9.1 . 协商延期

   客户端通过包含 |Sec-WebSocket- 请求扩展
   扩展| 标头字段，遵循 HTTP 的正常规则
   标头字段（参见[RFC2616]，第 4.2 节）和
   header 字段由以下 ABNF [ RFC2616 ]定义。注意
   本节使用 [ RFC2616 ] 中的ABNF 语法/规则，包括
   “隐含的 *LWS 规则”。如果客户端或
   协商过程中不符合ABNF的服务器
   下面，这种格式错误的数据的接收者必须立即_Fail
   WebSocket 连接_。

         Sec-WebSocket-Extensions = 扩展列表
         扩展列表= 1#扩展
         extension = extension-token *( ";" extension-param )
         扩展令牌 = 注册令牌
         注册令牌 = 令牌
         扩展参数=令牌[“=”（令牌|带引号的字符串）]
             ;当使用带引号的字符串语法变体时，值
             ;引用字符串转义后必须符合
             ;'令牌'ABNF。










Fette & Melnikov 标准跟踪 [第 48 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   请注意，与其他 HTTP 标头字段一样，此标头字段可能是
   跨多行拆分或合并。因此，以下是
   相等的：

         Sec-WebSocket-Extensions: foo
         Sec-WebSocket-Extensions: bar; 巴兹=2

   完全等同于

         Sec-WebSocket-Extensions: foo, bar; 巴兹=2

   使用的任何扩展令牌必须是注册令牌（请参阅
   第 11.4 节）。任何给定扩展提供的参数必须
   为该扩展定义。请注意，客户仅提供
   使用任何宣传的扩展程序，并且不得使用它们，除非
   服务器表示它希望使用扩展。

   请注意，扩展的顺序很重要。任何互动
   可以在定义的文档中定义多个扩展之间
   扩展名。在没有这样的定义的情况下，
   解释是客户端在其
   request 表示它希望使用的头字段的偏好，
   列出的第一个选项是最可取的。扩展名
   服务器在响应中列出的扩展名代表实际中的扩展名
   用于连接。扩展是否应该修改数据和/或
   帧，数据的操作顺序应该被假定为
   与扩展名在
   服务器在打开握手中的响应。

   例如，如果有两个扩展名“foo”和“bar”，如果
   头域 |Sec-WebSocket-Extensions| 服务器发送的
   值“foo, bar”，则对数据的操作将作为
   bar(foo(data))，是对数据本身的那些更改（例如
   压缩）或对可能“堆叠”的帧进行更改。

   可接受的扩展头域的非规范示例（注意
   折叠长行以提高可读性）：

         Sec-WebSocket-Extensions: deflate-stream
         Sec-WebSocket-Extensions: mux; 最大通道数=4；流量控制，
          放气流
         Sec-WebSocket-Extensions：私有扩展

   服务器通过包含一个或多个扩展来接受一个或多个扩展
   |Sec-WebSocket-扩展| 头字段包含一个或多个
   客户端请求的扩展。的解释





Fette & Melnikov 标准跟踪 [第 49 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   任何扩展参数，以及什么构成了一个有效的响应
   服务器到客户端请求的一组参数，将被定义
   通过每个这样的扩展。

9.2 . 已知扩展

   扩展为实现选择加入提供了一种机制
   附加协议功能。本文档没有定义任何
   扩展，但实现可以使用单独定义的扩展。

10 . 安全注意事项

   本节描述了一些适用于
   网络套接字协议。描述了特定的安全注意事项
   在本节的小节中。

10.1 . 非浏览器客户端

   WebSocket 协议可防止恶意 JavaScript 运行
   在受信任的应用程序（如 Web 浏览器）中，例如，通过
   检查|原产地| 标头字段（见下文）。见第 1.6 节
   了解更多详情。这种假设在这种情况下不成立
   一个更有能力的客户。

   虽然此协议旨在供网页中的脚本使用，
   主机也可以直接使用。这样的主持人正在采取行动
   以他们自己的名义，因此可以发送假|原产地| 标题字段，
   误导服务器。因此，服务器应该小心
   假设他们直接与来自已知来源的脚本交谈
   并且必须考虑到它们可能会以意想不到的方式被访问。在
   特别是，服务器不应该相信任何输入都是有效的。

   示例：如果服务器使用输入作为 SQL 查询的一部分，则所有输入
   文本在传递到 SQL 服务器之前应该被转义，以免
   服务器容易受到 SQL 注入的影响。

10.2 . 原产地注意事项

   不打算处理来自任何网页的输入的服务器，但
   仅对于某些站点应该验证 |Origin| 领域是一个起源
   他们期待。如果指定的来源不被服务器接受，
   然后它应该用回复来响应 WebSocket 握手
   包含 HTTP 403 禁止状态代码。

   |起源| 标头字段保护免受攻击情况，当
   不受信任方通常是 JavaScript 应用程序的作者
   在受信任客户端的上下文中执行。客户端
   本身可以联系服务器，并通过|Origin|的机制。



Fette & Melnikov 标准跟踪 [第 50 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   header 字段，决定是否扩展那些通信
   JavaScript 应用程序的权限。目的不是为了
   防止非浏览器建立连接，而是
   确保受信任的浏览器处于潜在的控制之下
   恶意 JavaScript 无法伪造 WebSocket 握手。

10.3 . 对基础设施的攻击（屏蔽）

   除了通过 WebSockets 成为攻击目标的端点之外，
   网络基础设施的其他部分，例如代理，可能是
   攻击的对象。

   在开发该协议时，进行了一项实验以
   展示一类导致中毒的代理攻击
   在野外部署的缓存代理 [ TALKING ]。一般形式
   攻击的目的是建立与服务器下的连接
   “攻击者”控制，在 HTTP 连接上执行 UPGRADE
   类似于 WebSocket 协议建立一个
   连接，然后通过该 UPGRADEd 连接发送数据
   看起来像是对特定已知资源的 GET 请求（其中
   在攻击中可能类似于广泛部署的脚本
   用于跟踪广告服务网络上的点击量或资源）。这
   远程服务器会用看起来像
   对假 GET 请求的响应，该响应将被缓存
   通过非零百分比的部署中介，从而中毒
   缓存。这种攻击的净效果是，如果用户
   可以说服访问攻击者控制的网站，
   攻击者可能会毒害该用户和其他人的缓存
   用户在同一缓存后面并在其他缓存上运行恶意脚本
   起源，危及网络安全模型。

   为避免对已部署的中介机构进行此类攻击，
   足以在应用程序提供的数据前面加上框架
   不符合 HTTP，因为不可能穷举
   发现并测试每个不符合要求的中介都不会跳过
   此类非 HTTP 帧并在帧有效负载上错误地操作。
   因此，采取的防御措施是将所有数据从客户端屏蔽到
   服务器，以便远程脚本（攻击者）无法控制
   关于正在发送的数据如何出现在线路上，因此不能
   构建一个可能被中间人误解的消息
   作为 HTTP 请求。

   客户端必须为每一帧选择一个新的掩码键，使用
   提供无法由终端应用程序预测的算法
   数据。例如，每个掩码都可以从一个
   加密强随机数生成器。如果相同的键是
   使用或存在可解释的模式来选择下一个密钥，
   攻击者可以发送一条消息，当被屏蔽时，该消息可能看起来像



Fette & Melnikov 标准跟踪 [第 51 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   一个 HTTP 请求（通过获取攻击者希望看到的消息
   线并用下一个要使用的屏蔽键屏蔽它，
   当客户端申请时，屏蔽密钥将有效地取消屏蔽数据
   它）。

   还有必要的是，一旦从一个帧传输
   客户端已经开始，该负载（应用程序提供的数据）
   框架不能被应用程序修改。
   否则，攻击者可以发送一个长帧，其中初始数据
   是一个已知值（例如全零），计算掩码键为
   收到第一部分数据后使用，然后修改
   尚未在帧中发送以显示为 HTTP 请求的数据
   蒙面时。（这本质上与
   上一段使用已知或可预测的掩码键。）
   如果要发送附加数据或要发送的数据以某种方式
   更改，必须在新帧中发送新的或更改的数据，并且
   因此有了新的掩码密钥。简而言之，一次传输一帧
   开始，内容不能被远程脚本修改
   （应用）。

   受保护的威胁模型是一种客户端
   发送看似 HTTP 请求的数据。如此一来，频道
   需要屏蔽的是从客户端到服务器的数据。
   可以使从服务器到客户端的数据看起来像一个
   响应，但要完成此请求，客户端还必须
   能够伪造请求。因此，认为没有必要
   双向屏蔽数据（从服务器到客户端的数据
   没有被屏蔽）。

   尽管屏蔽提供了保护，但不合规的 HTTP
   代理仍然容易受到这种类型的中毒攻击
   不应用屏蔽的客户端和服务器。

10.4 . 实施特定限制

   具有特定于实现和/或平台的实现
   关于帧大小或总消息大小的限制
   从多个框架重新组装必须保护自己免受
   超过这些限制。（例如，恶意端点可以尝试
   耗尽其对等方的内存或发起拒绝服务攻击
   发送单个大帧（例如，大小为 2**60）或通过发送
   一长串小帧是碎片的一部分
   消息。）这样的实现应该对帧施加限制
   从多个重新组装后的大小和总消息大小
   帧。






Fette & Melnikov 标准跟踪 [第 52 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


10.5 . WebSocket 客户端身份验证

   该协议没有规定服务器可以使用的任何特定方式
   在 WebSocket 握手期间验证客户端。网络套接字
   服务器可以使用任何可用的客户端身份验证机制
   通用 HTTP 服务器，例如 cookie、HTTP 身份验证或 TLS
   验证。

10.6 . 连接保密性和完整性

   连接机密性和完整性是通过运行
   基于 TLS 的 WebSocket 协议（wss URI）。WebSocket 实现
   必须支持 TLS 并且应该在与他们的通信时使用它
   同行。

   对于使用 TLS 的连接，TLS 提供的好处数量
   很大程度上取决于在此期间协商的算法的强度
   TLS 握手。例如，某些 TLS 密码机制不
   提供连接机密性。为了达到合理的水平
   保护，客户端应仅使用强 TLS 算法。“网络
   安全上下文：用户界面指南”
   [ W3C.REC-wsc-ui-20100812 ] 讨论了强 TLS 的构成
   算法。[ RFC5246 ] 在附录 A.5
   和附录 D.3 中提供了额外的指导。

10.7 . 无效数据的处理

   传入数据必须始终由客户端和服务器验证。
   如果在任何时候，一个端点面临着它没有的数据
   理解或违反端点所依据的某些标准
   确定输入的安全性，或者当端点看到开口时
   与它期望的值不对应的握手
   （例如，客户端请求中不正确的路径或来源），端点
   可能会断开 TCP 连接。如果在之后收到无效数据
   一个成功的 WebSocket 握手，端点应该发送一个 Close
   帧与适当的状态代码（第 7.4 节），然后再继续
   _关闭 WebSocket 连接_。使用 Close 框架与
   适当的状态代码可以帮助诊断问题。如果
   在 WebSocket 握手期间发送无效数据，服务器
   应该返回适​​当的 HTTP [ RFC2616 ] 状态代码。

   发送文本数据时会出现一类常见的安全问题
   使用错误的编码。该协议指定带有
   文本数据类型（与二进制或其他类型相反）包含 UTF-8-
   编码数据。虽然仍然标明长度和
   实现这个协议的应用程序应该使用长度
   确定帧实际结束的位置，以不正确的方式发送数据




Fette & Melnikov 标准跟踪 [第 53 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   编码可能仍会打破应用程序构建在上面的假设
   本协议的内容可能会导致任何误解
   数据丢失或潜在的安全漏洞。

10.8 . 通过 WebSocket 握手使用 SHA-1

   本文档中描述的 WebSocket 握手不依赖于
   SHA-1 的任何安全属性，例如抗碰撞性或
   抵抗第二次原像攻击（如
   [ RFC4270 ]）。

11 . IANA 考虑事项

11.1 . 新 URI 方案的注册

11.1.1 . 注册“ws”计划

   一个 |ws| URI 标识 WebSocket 服务器和资源名称。

   URI 方案名称
      WS

   地位
      永恒的

   URI 方案语法
      使用来自 URI的 ABNF [ RFC5234 ] 语法和 ABNF 终端
      规范 [ RFC3986 ]：

           "ws:" "//" 权限路径-abempty [ "?" 询问 ]

   <path-abempty> 和 <query> [ RFC3986 ] 组件构成资源
   名称发送到服务器以标识所需的服务类型。
   其他组件具有 [ RFC3986 ] 中描述的含义。

   URI 方案语义
      此方案的唯一操作是使用打开连接
      WebSocket 协议。

   编码注意事项
      语法排除的宿主组件中的字符
      上面定义的必须按照指定从 Unicode 转换为 ASCII
      在 [ RFC3987 ] 或其替代品中。出于基于方案的目的
      规范化、国际化域名 (IDN) 形式
      考虑宿主组件及其向 punycode 的转换
      等效（参见[RFC3987] 的第 5.3.3 节）。





Fette & Melnikov 标准跟踪 [第 54 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


      语法排除的其他组件中的字符
      上面定义的必须首先从 Unicode 转换为 ASCII
      将字符编码为 UTF-8，然后替换
      对应的字节使用它们的百分比编码形式，如定义
      URI [ RFC3986 ] 和国际化资源标识符 (IRI)
      [ RFC3987 ] 规范。

   使用此 URI 方案名称的应用程序/协议
      网络套接字协议

   互操作性注意事项
      使用 WebSocket 需要使用 HTTP 1.1 或更高版本。

   安全考虑
      请参阅“安全注意事项”部分。

   接触
      HYBI 工作组 <hybi@ietf.org>

   作者/更改控制器
      IETF <iesg@ietf.org>

   参考
      RFC 6455

11.1.2 . 注册“wss”计划

   一个 |wss| URI 标识 WebSocket 服务器和资源名称以及
   表示通过该连接的流量将通过以下方式受到保护
   TLS（包括 TLS 的标准优势，例如数据机密性
   以及完整性和端点身份验证）。

   URI 方案名称
      wss

   地位
      永恒的

   URI 方案语法
      使用来自 URI的 ABNF [ RFC5234 ] 语法和 ABNF 终端
      规范 [ RFC3986 ]：

           "wss:" "//" 权限路径-abempty [ "?" 询问 ]

   <path-abempty> 和 <query> 组件构成发送的资源名称
   到服务器以识别所需的服务类型。其他
   组件具有 [ RFC3986 ] 中描述的含义。




Fette & Melnikov 标准跟踪 [第 55 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   URI 方案语义
      此方案的唯一操作是使用打开连接
      使用 TLS 加密的 WebSocket 协议。

   编码注意事项
      语法排除的宿主组件中的字符
      上面定义的必须按照指定从 Unicode 转换为 ASCII
      在 [ RFC3987 ] 或其替代品中。出于基于方案的目的
      主机组件的规范化 IDN 形式及其
      转换为 punycode 被认为是等效的（参见[RFC3987] 的第
      5.3.3节）。

      语法排除的其他组件中的字符
      上面定义的必须首先从 Unicode 转换为 ASCII
      将字符编码为 UTF-8，然后替换
      对应的字节使用它们的百分比编码形式，如定义
      URI [ RFC3986 ] 和 IRI [ RFC3987 ] 规范。

   使用此 URI 方案名称的应用程序/协议
      基于 TLS 的 WebSocket 协议

   互操作性注意事项
      使用 WebSocket 需要使用 HTTP 1.1 或更高版本。

   安全考虑
      请参阅“安全注意事项”部分。

   接触
      HYBI 工作组 <hybi@ietf.org>

   作者/更改控制器
      IETF <iesg@ietf.org>

   参考
      RFC 6455

11.2 . 注册“WebSocket”HTTP 升级关键字

   本节定义了在 HTTP Upgrade Tokens 中注册的关键字
   根据RFC 2817 [ RFC2817 ] 注册。

   代币名称
      网络套接字

   作者/更改控制器
      IETF <iesg@ietf.org>





Fette & Melnikov 标准跟踪 [第 56 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   接触
      HYBI <hybi@ietf.org>

   参考
      RFC 6455

11.3 . 注册新的 HTTP 标头字段

11.3.1 . Sec-WebSocket-Key

   本节描述了在 Permanent
   消息头字段名称注册表 [ RFC3864 ]。

   标题字段名称
      Sec-WebSocket-Key

   适用协议
      http

   地位
      标准

   作者/更改控制器
      国际工作组

   规范文件
      RFC 6455

   相关信息
      此头域仅用于 WebSocket 开启握手。

   |Sec-WebSocket-Key| header 字段用于 WebSocket 开头
   握手。它从客户端发送到服务器以提供部分
   服务器用来证明它收到了一个信息的信息
   有效的 WebSocket 打开握手。这有助于确保服务器
   不接受来自非 WebSocket 客户端的连接（例如 HTTP
   客户端）被滥用以将数据发送到毫无戒心的 WebSocket
   服务器。

   |Sec-WebSocket-Key| 标头字段不得多次出现
   在 HTTP 请求中。










Fette & Melnikov 标准跟踪 [第 57 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


11.3.2 . Sec-WebSocket-扩展

   本节描述用于注册的头域
   永久消息头字段名称注册表 [ RFC3864 ]。

   标题字段名称
      Sec-WebSocket-扩展

   适用协议
      http

   地位
      标准

   作者/更改控制器
      国际工作组

   规范文件
      RFC 6455

   相关信息
      此头域仅用于 WebSocket 开启握手。

   |Sec-WebSocket-Extensions| 标头字段在 WebSocket 中使用
   打开握手。它最初从客户端发送到
   服务器，然后随后从服务器发送到客户端，以
   同意在持续时间内使用的一组协议级扩展
   的连接。

   |Sec-WebSocket-Extensions| 标题字段可能出现多次
   在 HTTP 请求中（逻辑上与单个请求相同）
   |Sec-WebSocket-扩展| 包含所有值的标头字段。
   但是，|Sec-WebSocket-Extensions| 标题字段不得出现
   在 HTTP 响应中不止一次。

11.3.3 . Sec-WebSocket-接受

   本节描述了在 Permanent
   消息头字段名称注册表 [ RFC3864 ]。

   标题字段名称
      Sec-WebSocket-接受

   适用协议
      http

   地位
      标准



Fette & Melnikov 标准跟踪 [第 58 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   作者/更改控制器
      国际工作组

   规范文件
      RFC 6455

   相关信息
      这个头域只用于WebSocket开启
      握手。

   |Sec-WebSocket-Accept| 标头字段在 WebSocket 中使用
   打开握手。它从服务器发送到客户端
   确认服务器愿意发起 WebSocket
   联系。

   |Sec-WebSocket-Accept| 标头不得多次出现在
   一个 HTTP 响应。

11.3.4 . Sec-WebSocket-协议

   本节描述了在 Permanent
   消息头字段名称注册表 [ RFC3864 ]。

   标题字段名称
      Sec-WebSocket-协议

   适用协议
      http

   地位
      标准

   作者/更改控制器
      国际工作组

   规范文件
      RFC 6455

   相关信息
      这个头域只用于WebSocket开启
      握手。

   |Sec-WebSocket-Protocol| 标头字段在 WebSocket 中使用
   打开握手。它从客户端发送到服务器并返回
   从服务器到客户端确认子协议
   联系。这使脚本既可以选择子协议，也可以
   确保服务器同意为该子协议提供服务。




Fette & Melnikov 标准跟踪 [第 59 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   |Sec-WebSocket-Protocol| 标题字段可能出现多次
   在 HTTP 请求中（逻辑上与单个请求相同）
   |Sec-WebSocket-协议| 包含所有值的标头字段）。
   但是，|Sec-WebSocket-Protocol| 标题字段不得出现
   在 HTTP 响应中不止一次。

11.3.5 . Sec-WebSocket-版本

   本节描述了在 Permanent
   消息头字段名称注册表 [ RFC3864 ]。

   标题字段名称
      Sec-WebSocket-版本

   适用协议
      http

   地位
      标准

   作者/更改控制器
      国际工作组

   规范文件
      RFC 6455

   相关信息
      这个头域只用于WebSocket开启
      握手。

   |Sec-WebSocket-Version| 标头字段在 WebSocket 中使用
   打开握手。它从客户端发送到服务器
   指示连接的协议版本。这使
   服务器正确解释打开握手和后续
   正在从数据发送数据，如果服务器关闭连接
   无法以安全的方式解释该数据。|Sec-WebSocket-
   版本| 标头字段也从服务器发送到客户端
   WebSocket 握手错误，当从客户端收到版本时
   与服务器理解的版本不匹配。在这种情况下，
   头域包括支持的协议版本
   服务器。

   请注意，不期望更高的版本号
   必须向后兼容较低的版本号。







Fette & Melnikov 标准跟踪 [第 60 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   |Sec-WebSocket-Version| 标头字段可能多次出现在
   一个 HTTP 响应（在逻辑上与单个
   |Sec-WebSocket-版本| 包含所有值的标头字段）。
   但是，|Sec-WebSocket-Version| 标题字段不得出现
   在 HTTP 请求中不止一次。

11.4 . WebSocket 扩展名称注册表

   该规范为 WebSocket 创建了一个新的 IANA 注册中心
   与 WebSocket 协议一起使用的扩展名
   遵循RFC 5226 [ RFC5226 ] 中规定的原则。

   作为此注册表的一部分，IANA 维护以下信息：

   分机标识符
      扩展的标识符，将在
      |Sec-WebSocket-扩展| 注册的头字段
      本规范的第 11.3.2 节。该值必须符合第 9.1 节中
      定义的扩展令牌的要求
      本规范的。

   扩展名
      扩展名，因为扩展名通常被称为
      到。

   扩展定义
      对使用扩展名的文档的引用
      定义了 WebSocket 协议。

   已知的不兼容扩展
      已知此扩展名的扩展标识符列表
      不相容。

   WebSocket 扩展名称受“先到先得”的约束
   服务于“IANA 注册政策 [ RFC5226 ]。

   此注册表中没有初始值。

11.5 . WebSocket 子协议名称注册表

   该规范为 WebSocket 创建了一个新的 IANA 注册中心
   与 WebSocket 协议一起使用的子协议名称
   符合RFC 5226 [ RFC5226 ] 中规定的原则。








Fette & Melnikov 标准跟踪 [第 61 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   作为此注册表的一部分，IANA 维护以下信息：

   子协议标识符
      子协议的标识符，将在
      |Sec-WebSocket-协议| 在第 11.3.4 节中注册的标头字段
      本规范的。值必须符合要求
      在本规范第 4.1 节第10 项中给出——即，
      该值必须是RFC 2616 [ RFC2616 ]定义的令牌。

   子协议公用名
      子协议的名称，因为子协议通常是
      提到。

   子协议定义
      对使用子协议的文档的引用
      用 WebSocket 协议定义。

   WebSocket 子协议名称受“先来
   First Served” IANA 注册政策 [ RFC5226 ]。

11.6 . WebSocket 版本号注册表

   该规范为 WebSocket 版本创建了一个新的 IANA 注册中心
   根据 WebSocket 协议使用的数字RFC 5226 [ RFC5226 ] 中
   规定的原则。

   作为此注册表的一部分，IANA 维护以下信息：

   版本号
      |Sec-WebSocket-Version| 中使用的版本号 是
      在本规范的第 4.1 节中指定。该值必须是
      一个介于 0 和 255（含）之间的非负整数。

   参考
      请求新版本号或草案名称的 RFC
      版本号（见下文）。

   地位
      “临时”或“标准”。请参阅下面的说明。

   版本号被指定为“临时”或“标准”。

   “标准”版本号记录在 RFC 中并用于
   确定 WebSocket 协议的主要稳定版本，例如
   此 RFC 定义的版本。“标准”版本号是
   受“IETF 审查”IANA 注册政策 [ RFC5226 ] 的约束。





Fette & Melnikov 标准跟踪 [第 62 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   “临时”版本号记录在 Internet 草案和
   用于帮助实现者识别和互操作已部署的
   WebSocket 协议的版本，例如之前开发的版本
   此 RFC 的发布。“临时”版本号为主题
   到“专家审查”IANA 注册政策 [ RFC5226 ]，与
   HYBI 工作组的主席（或者，如果工作组关闭，
   IETF 应用领域的区域主管）是最初的
   指定专家。

   IANA 已将初始值添加到注册表中，如下所示。

   +--------+---------------------------------------- -+-----------+
   |版本| 参考 | 状态 |
   | 数量 | | |
   +--------+---------------------------------------- -+-----------+
   | 0 +草案-ietf-hybi-thewebsocketprotocol-00 | 临时|
   +--------+---------------------------------------- -+-----------+
   | 1 +草案-ietf-hybi-thewebsocketprotocol-01 | 临时|
   +--------+---------------------------------------- -+-----------+
   | 2 + Draft-ietf-hybi-thewebsocketprotocol-02 | 临时|
   +--------+---------------------------------------- -+-----------+
   | 3 + Draft-ietf-hybi-thewebsocketprotocol-03 | 临时|
   +--------+---------------------------------------- -+-----------+
   | 4 + Draft-ietf-hybi-thewebsocketprotocol-04 | 临时|
   +--------+---------------------------------------- -+-----------+
   | 5 +草案-ietf-hybi-thewebsocketprotocol-05 | 临时|
   +--------+---------------------------------------- -+-----------+
   | 6 +草案-ietf-hybi-thewebsocketprotocol-06 | 临时|
   +--------+---------------------------------------- -+-----------+
   | 7 + Draft-ietf-hybi-thewebsocketprotocol-07 | 临时|
   +--------+---------------------------------------- -+-----------+
   | 8 +草案-ietf-hybi-thewebsocketprotocol-08 | 临时|
   +--------+---------------------------------------- -+-----------+
   | 9 + 保留 | |
   +--------+---------------------------------------- -+-----------+
   | 10 + 保留 | |
   +--------+---------------------------------------- -+-----------+
   | 11 + 保留 | |
   +--------+---------------------------------------- -+-----------+
   | 12 + 保留 | |
   +--------+---------------------------------------- -+-----------+
   | 13 +                 RFC 6455                  | 标准 |
   +--------+---------------------------------------- -+-----------+








Fette & Melnikov 标准跟踪 [第 63 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


11.7 . WebSocket 关闭代码编号注册表

   该规范为 WebSocket 创建了一个新的 IANA 注册中心
   Connection Close Code Numbers 按照原则设置
   在RFC 5226 [ RFC5226 ] 中。

   作为此注册表的一部分，IANA 维护以下信息：

   状态码
      状态代码表示 WebSocket 连接的原因
      按照本文档的第 7.4 节关闭。状态码是
      1000 到 4999（含）之间的整数。

   意义
      状态码的含义。每个状态码都必须有一个
      独特的意义。

   接触
      保留状态代码的实体的联系人。

   参考
      请求状态代码并定义它们的稳定文档
      意义。这是 1000-2999 范围内的状态代码所必需的
      并推荐用于 3000-3999 范围内的状态代码。

   WebSocket Close Code Numbers 以不同的注册方式为准
   要求取决于它们的范围。请求状态码
   本协议及其后续版本或扩展使用
   受任何一项“标准行动”、“规范
   必需”（这意味着“指定专家”），或“IESG 审查”IANA
   注册政策，应在 1000-2999 范围内授予。
   请求库、框架和使用的状态代码
   应用程序受“先到先得”IANA 的约束
   注册政策，应在 3000-3999 范围内授予。
   从 4000-4999 的状态码范围指定为 Private
   用。请求应表明它们是否处于请求状态
   供 WebSocket 协议（或未来版本的
   协议）、扩展或库/框架/应用程序。













Fette & Melnikov 标准跟踪 [第 64 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   IANA 已将初始值添加到注册表中，如下所示。

     |状态码​​ | 含义 | 联系 | 参考 |
    -+------------+-----------------+--------------+- ----------|
     | 1000 | 正常关闭 | hybi@ietf.org | RFC 6455   |
    -+------------+-----------------+--------------+- ----------|
     | 1001 | 离开 | hybi@ietf.org | RFC 6455   |
    -+------------+-----------------+--------------+- ----------|
     | 1002 | 协议错误 | hybi@ietf.org | RFC 6455   |
    -+------------+-----------------+--------------+- ----------|
     | 1003 | 不支持的数据| hybi@ietf.org | RFC 6455   |
    -+------------+-----------------+--------------+- ----------|
     | 1004 | ---保留--- | hybi@ietf.org | RFC 6455   |
    -+------------+-----------------+--------------+- ----------|
     | 1005 | 无状态接收 | hybi@ietf.org | RFC 6455   |
    -+------------+-----------------+--------------+- ----------|
     | 1006 | 异常关闭| hybi@ietf.org | RFC 6455   |
    -+------------+-----------------+--------------+- ----------|
     | 1007 | 无效帧 | hybi@ietf.org | RFC 6455   |
     | | 有效载荷数据 | | |
    -+------------+-----------------+--------------+- ----------|
     | 1008 | 政策违规| hybi@ietf.org | RFC 6455   |
    -+------------+-----------------+--------------+- ----------|
     | 1009 | 消息太大 | hybi@ietf.org | RFC 6455   |
    -+------------+-----------------+--------------+- ----------|
     | 1010 | 强制分机 | hybi@ietf.org | RFC 6455   |
    -+------------+-----------------+--------------+- ----------|
     | 1011 | 内部服务器 | hybi@ietf.org | RFC 6455   |
     | | 错误 | | |
    -+------------+-----------------+--------------+- ----------|
     | 1015 | TLS 握手 | hybi@ietf.org | RFC 6455   |
    -+------------+-----------------+--------------+- ----------|

11.8 . WebSocket 操作码注册表

   该规范为 WebSocket 操作码创建了一个新的 IANA 注册中心
   根据RFC 5226 [ RFC5226 ]中规定的原则。

   作为此注册表的一部分，IANA 维护以下信息：

   操作码
      操作码表示 WebSocket 帧的帧类型，如
      在第 5.2 节中定义。操作码是一个介于 0 之间的整数
      和 15，包括。

   意义
      操作码值的含义。




Fette & Melnikov 标准跟踪 [第 65 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   参考
      请求操作码的规范。

   WebSocket 操作码编号受 IANA“标准行动”的约束
   注册政策 [ RFC5226 ]。

   IANA 已将初始值添加到注册表中，如下所示。

     |操作码 | 含义 | 参考 |
    -+--------+--------------------------------------+- ----------|
     | 0 | 延续框架 | RFC 6455   |
    -+--------+--------------------------------------+- ----------|
     | 1 | 文本框 | RFC 6455   |
    -+--------+--------------------------------------+- ----------|
     | 2 | 二进制帧 | RFC 6455   |
    -+--------+--------------------------------------+- ----------|
     | 8 | 连接关闭框架 | RFC 6455   |
    -+--------+--------------------------------------+- ----------|
     | 9 | 平帧| RFC 6455   |
    -+--------+--------------------------------------+- ----------|
     | 10 | 乒乓球架 | RFC 6455   |
    -+--------+--------------------------------------+- ----------|

11.9 . WebSocket 帧头位注册表

   该规范为 WebSocket 框架创建了一个新的 IANA 注册中心
   Header Bits 符合RFC 5226
   [ RFC5226 ]中规定的原则。此注册表控制标记的位的分配5.2 节中的
   RSV1、RSV2 和 RSV3 。

   这些位是为将来的版本或扩展保留的
   规格。

   WebSocket 帧头位分配受
   “标准行动”IANA 注册政策 [ RFC5226 ]。

12 . 使用其他规范中的 WebSocket 协议

   WebSocket 协议旨在供其他人使用
   为动态作者提供通用机制的规范
   定义的内容，例如，在定义脚本 API 的规范中。

   这样的规范首先需要_建立一个WebSocket
   Connection_，为该算法提供：

   o 目的地，由 /host/ 和 /port/ 组成。





Fette & Melnikov 标准跟踪 [第 66 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   o /resource name/，它允许多个服务
      在一台主机和端口上识别。

   o /secure/ 标志，如果要连接，则为真
      否则加密和假。

   o正在制作的原点 [ RFC6454 ]的 ASCII 序列化
      负责连接。

   o 可选的，标识要分层的协议的字符串
      通过 WebSocket 连接。

   /host/、/port/、/resource name/ 和 /secure/ 标志通常是
   使用解析 WebSocket URI 的步骤从 URI 获得
   成分。如果 URI 未指定
   网络套接字。

   如果在任何时候要关闭连接，则规范
   需要使用_关闭WebSocket连接_算法
   （第 7.1.1 节）。

   7.1.4 节定义了_WebSocket 连接何时关闭_。

   当连接打开时，规范将需要处理
   _A WebSocket 消息已收到的情况_（第 6.2 节）。

   要将一些数据 /data/ 发送到打开的连接，规范
   需要_发送一个 WebSocket 消息_（第 6.1 节）。

13 . 致谢

   特别感谢原作者 Ian Hickson
   和本协议的编辑。这个的初步设计
   规范得益于许多人的参与
   WHATWG 和 WHATWG 邮件列表。对该规范的贡献
   不是按部分跟踪的，而是所有对此做出贡献的人的列表
   规范在 WHATWG HTML 规范中给出
   http://whatwg.org/html5。

   还要特别感谢 John Tamplin 提供了重要的
   本规范“数据框架”部分的文本量。

   还要特别感谢 Adam Barth 提供了大量
   的“数据屏蔽”部分的文本和背景研究
   本规范。






Fette & Melnikov 标准跟踪 [第 67 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   特别感谢 Lisa Dusseault 对 Apps Area 的评论（以及
   帮助开始这项工作），理查德·巴恩斯（Richard Barnes）为 Gen-Art 评论，
   和 Magnus Westerlund 负责交通区域审查。特别感谢
   致 HYBI WG 过去和现在的 WG 椅子，他们在背后不知疲倦地工作
   推动这项工作完成的场景：Joe Hildebrand，
   萨尔瓦多·洛雷托和加布里埃尔·黑山。最后但并非最不重要，
   特别感谢负责的区域总监 Peter Saint-Andre。

   感谢以下参与讨论的人
   HYBI WG 邮件列表和贡献的想法和/或提供
   详细评论（列表可能不完整）：Greg Wilkins，
   约翰·坦普林、威利·塔罗、麦基·斯塔乔维亚克、杰米·洛基尔、斯科特
   弗格森、比约恩·霍曼、朱利安·雷施克、戴夫·克里德兰、安迪
   格林，埃里克·雷斯科拉，伊纳基·巴兹·卡斯蒂略，马丁·汤姆森，罗伯托
   培恩、帕特里克·麦克马纳斯、钟宇、布鲁斯·阿瑟顿、吉野武、
   Martin J. Duerst, James Graham, Simon Pieters, Roy T. Fielding,
   Mykyta Yevstifeyev，Len Holgate，Paul Colomiets，Piotr Kulaga，Brian
   Raymor, Jan Koehler, Joonas Lehtolahti, Sylvain Hellegouarch, Stephen
   法瑞尔、肖恩·特纳、皮特·雷斯尼克、彼得·索森、乔·梅森、约翰
   福洛斯和亚历山大·菲利普。请注意，上面列出的人
   不一定认可这项工作的最终结果。

14 . 参考

14.1 . 规范参考

   [ ANSI.X3-4.1986 ]
              美国国家标准协会，“编码字符
              设置 - 7 位美国信息标准代码
              交换”，ANSI X3.4，1986 年。

   [ FIPS.180-3 ]
              美国国家标准与技术研究院，“安全
              哈希标准”，FIPS PUB 180-3，2008 年 10 月，
              < http://csrc.nist.gov/publications/fips/fips180-3/
              fips180-3_final.pdf >。

   [ RFC1928 ] Leech, M.、Ganis, M.、Lee, Y.、Kuris, R.、Koblas, D. 和
              L. Jones，“SOCKS 协议第 5 版”，RFC 1928，
              1996 年 3 月。

   [ RFC2119 ] Bradner, S.，“在 RFC 中使用的关键词来表示
              要求级别”，BCP 14，RFC 2119，1997年 3 月。

   [ RFC2616 ] Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L.、Leach, P. 和 T. Berners-Lee，“超文本
              传输协议 -- HTTP/1.1”，RFC 2616，1999年 6 月。




Fette & Melnikov 标准跟踪 [第 68 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   [ RFC2817 ] Khare, R. 和 S. Lawrence，“升级到 TLS
              HTTP/1.1”，RFC 2817，2000年 5 月。

   [ RFC2818 ] Rescorla, E.，“HTTP Over TLS”，RFC 2818，2000年 5 月。

   [ RFC3629 ] Yergeau, F.，“UTF-8，ISO 的一种转换格式
              10646"，STD 63，RFC 3629，2003年 11 月。

   [ RFC3864 ] Klyne, G.、Nottingham, M. 和 J. Mogul，“注册
              消息头字段程序”，BCP 90，RFC 3864，
              2004 年 9 月。

   [ RFC3986 ] Berners-Lee, T.、Fielding, R. 和 L. Masinter，“制服
              资源标识符 (URI)：通用语法”，STD 66，
              RFC 3986，2005年 1 月。

   [ RFC3987 ] Duerst, M. 和 M. Suignard，“国际化资源
              标识符 (IRI)”，RFC 3987，2005年 1 月。

   [ RFC4086 ] Eastlake, D.、Schiller, J. 和 S. Crocker，“随机性
              安全要求”，BCP 106，RFC 4086，2005年 6 月。

   [ RFC4648 ] Josefsson, S.，“Base16、Base32 和 Base64 数据
              编码”，RFC 4648，2006年 10 月。

   [ RFC5226 ] Narten, T. 和 H. Alvestrand，“编写
              RFC 中的 IANA 考虑部分”，BCP 26，RFC 5226，
              2008 年 5 月。

   [ RFC5234 ] Crocker, D. 和 P. Overell，“用于语法的增强型 BNF
              规范：ABNF”，STD 68，RFC 5234，2008年 1 月。

   [ RFC5246 ] Dierks, T. 和 E. Rescorla，“传输层安全
              (TLS) 协议版本 1.2”，RFC 5246，2008年 8 月。

   [ RFC6066 ] Eastlake, D.，“传输层安全 (TLS) 扩展：
              扩展定义”，RFC 6066，2011年 1 月。

   [ RFC6454 ] Barth, A.，“Web 起源概念”，RFC 6454，
              2011 年 12 月。

14.2 . 参考资料

   [ RFC4122 ] Leach, P.、Mealling, M. 和 R. Salz，“A Universally
              唯一标识符 (UUID) URN 命名空间”，RFC 4122，
              2005 年 7 月。





Fette & Melnikov 标准跟踪 [第 69 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


   [ RFC4270 ] Hoffman, P. 和 B. Schneier，“对加密的攻击
              Internet 协议中的哈希值”，RFC 4270，2005年 11 月。

   [ RFC5321 ] Klensin, J.，“简单邮件传输协议”，RFC 5321，
              2008 年 10 月。

   [ RFC6202 ] Loreto, S.、Saint-Andre, P.、Salsano, S. 和 G. Wilkins，
              “使用 Long 的已知问题和最佳实践
              双向 HTTP 中的轮询和流式传输”，RFC 6202，
              2011 年 4 月。

   [ RFC6265 ] Barth, A.，“HTTP 状态管理机制”，RFC 6265，
              2011 年 4 月。

   [谈话] Huang, LS.、Chen, E.、Barth, A.、Rescorla, E. 和 C.
              杰克逊，“自言自语以获得乐趣和利润”，2010 年，
              < http://w2spconf.com/2011/papers/websocket.pdf >。

   [ W3C.REC-wsc-ui-20100812 ]
              Roessler, T. 和 A. Saldhana，“网络安全环境：用户
              接口指南”，万维网联盟
              建议 REC-wsc-ui-20100812，2010 年 8 月，
              < http://www.w3.org/TR/2010/REC-wsc-ui-20100812/ >。

              最新版本可在
              < http://www.w3.org/TR/wsc-ui/ >。

   [ WSAPI ] Hickson, I.，“WebSocket API”，W3C 工作草案 WD-
              websockets-20110929，2011 年 9 月，
              < http://www.w3.org/TR/2011/WD-websockets-20110929/ >。

              最新版本可在
              < http://www.w3.org/TR/websockets/ >。

   [ XMLHttpRequest ]
              van Kesteren, A., Ed., "XMLHttpRequest", W3C 候选人
              推荐 CR-XMLHttpRequest-20100803，2010 年 8 月，
              < http://www.w3.org/TR/2010/CR-XMLHttpRequest-20100803/ >。

              最新版本可在
              < http://www.w3.org/TR/XMLHttpRequest/ >。










Fette & Melnikov 标准跟踪 [第 70 页]

RFC 6455                  WebSocket 协议 2011 年 12 月


作者地址

   伊恩·费特
   谷歌公司

   电子邮件：ifette+ietf@google.com
   网址：http :    //www.ianfette.com/


   阿列克谢·梅尔尼科夫
   伊索德有限公司
   5 城堡商务村
   站路36号
   汉普顿，米德尔塞克斯 TW12 2BX
   英国

   电子邮件：Alexey.Melnikov@isode.com


































Fette & Melnikov 标准跟踪 [第 71 页]